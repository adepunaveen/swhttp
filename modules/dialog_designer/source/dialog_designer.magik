#% text_encoding = iso8859_1
#
# Copyright © 2007 iFactor Consulting, Inc. (http://www.ifactorconsulting.com)
#
# This software is released under the terms of version 2 of the
# GNU General Public License.  The full license text is
# provided in the license.txt file in the Dialog Designer product
# directory, and is also available at http://www.fsf.org.
#
########################################################################
##
## @author Graham Garlick
## @version 1.2 (June 2007)
##
## Dialog Designer - A GUI class for designing Smallworld Dialogs.
##
########################################################################
_package user
$

def_slotted_exemplar(:dialog_designer,
		     {
			     {:canvas,_unset,:writable},
			     {:items,_unset,:writable},
			     {:footprints,_unset,:writable},
			     {:rowcol_cells,_unset,:writable},
			     {:dialog_list,_unset,:writable}
		     },:plugin)
$

# List of widgets that have an associated insertion mode.
dialog_designer.define_shared_variable(
	:widget_actions,
	{
		:select_mode,
		:paste_element,
		:rowcol,
		:paned_window,
		:group_box,
		:tab_box,
		:window_stack,
		
		:button_item,
		:image_button_item, 
		:toggle_item,          
		:image_toggle_item,
		:text_choice_item,
		:text_item,
		:unit_text_item,
		:slider_item,
		
		:label_item,        
		:radio_group,        
		:radio_item,         
		:simple_list_item,    
		:text_window,
		:tabular_list,
		:tree_item,
		:canvas,

		:open_file_dir,
		:style_choice_item,
		:plugin_item,
		:dd_date_time_item,
		:dd_spinner_item
	}
	,:public)
$

# List of widget classes with their associated exemplars,  this
# could be replaced with a simple method ...
dialog_designer.define_shared_variable(
	:widget_exemplars,
	property_list.new_with(
		:rowcol,            rowcol,
		:paned_window,      paned_window,
		:button_item,       button_item,
		:group_box,         group_box,
		:image_button_item, image_button_item,
		:image_toggle_item, image_toggle_item,
		:label_item,        label_item,
		:radio_group,       radio_group,
		:radio_item,        radio_item,
		:simple_list_item,  simple_list_item,
		:text_choice_item,  text_choice_item,
		:text_item,         text_item,
		:unit_text_item,    unit_text_item,
		:text_window,       text_window,
		:toggle_item,       toggle_item, 
		:tabular_list,   dd_tabular_list,
		:tree_item,         dd_tree_list,
		:slider_item,       slider_item,
		:canvas,            scrollable_canvas,
		:tab_box,           tab_box,
		:window_stack,      window_stack,
		:open_file_dir,     dd_open_file_dir,
		:style_choice_item, dd_style_choice_item,
		:plugin_item,       dd_plugin_item,
		:dd_date_time_item, dd_date_time_item,
		:dd_spinner_item,   dd_spinner_item
		      )
	,:public)
$

# Selection line style
dialog_designer.define_shared_variable(
	:selection_line_style,
	line_style.new_with_properties(:foreground_colour,colour.called(:green),
				       :width,3),
	:public)
$
# Insertion drop area line style
dialog_designer.define_shared_variable(
	:insertion_line_style,
	line_style.new_with_properties(:foreground_colour,colour.called(:red),
				       :width,2),
	:public)
$
# The list of classes that act like rowcols, rowcol of course
# and a few new classes developed to make the dialog designer
# easier to use - they are used instead of specialty container
# objects so the rowcol methods can be used by all.
dialog_designer.define_shared_variable(
	:rowcol_like_objects,
	{:rowcol,:dd_paned_window,:dd_group_box,:dd_radio_group},
	:public)
$

# The list of actions used in the GUI with a generic type which
# keys a standard action specification.
dialog_designer.define_shared_variable(:action_specs,
	property_list.new_with(
		:select_mode,          :widget_toggle,
		:rowcol,               :widget_toggle,
		:paned_window,         :widget_toggle,
		:refresh_view,         :image_button,
		:copy_element,         :image_button,
		:paste_element,        :widget_toggle,
		:cut_element,          :image_button,
		:delete_element,       :image_button,
		:interrupt_refresh,    :image_button,
		:new_dialog,           :image_button,
		:copy,                 :image_button,
		:save_to_file,         :image_button,
		:load_from_file,       :image_button,
		:save_as,              :image_button,
		:exit,                 :image_button,
		:dialog_designer_help, :image_button,
		:use_menubar,          :toggle,
		:use_statusbar,        :toggle,
		:use_docks,            :toggle,
		:use_databus,          :toggle,
		:use_magik_xml,        :toggle,
		:button_item,          :widget_toggle,
		:group_box,            :widget_toggle,
		:image_button_item,    :widget_toggle,
		:image_toggle_item,    :widget_toggle,
		:label_item,           :widget_toggle,
		:open_file_dir,        :widget_toggle,
		:radio_group,          :widget_toggle,
		:radio_item,           :widget_toggle,
		:text_window,          :widget_toggle,
		:simple_list_item,     :widget_toggle,
		:text_choice_item,     :widget_toggle,
		:text_item,            :widget_toggle,
		:unit_text_item,       :widget_toggle,
		:toggle_item,          :widget_toggle,
		:tabular_list,         :widget_toggle,
		:tree_item,            :widget_toggle,
		:slider_item,          :widget_toggle,
		:canvas,               :widget_toggle,
		:style_choice_item,    :widget_toggle,
		:plugin_item,          :widget_toggle,
		:tab_box,              :widget_toggle,
		:window_stack,         :widget_toggle,
		:dd_date_time_item,    :widget_toggle,
		:dd_spinner_item,      :widget_toggle,
		:use_module_properties,:toggle,			
		:show_rowcol_cells,    :toggle,
		:dialog_list,          :text_choice,
		:delete_dialog,        :image_button,
		:set_module_path,      :image_button,
		:build_module,         :button,
		:build_and_activate,   :button,
		:explore_code,         :image_button,
		:reactivate_dialog,    :button,
		:dialog_class_list,    :text_choice,
		:dialog_method_list,   :text_choice,
		:dialog_default_method,:button,
		:refresh_app_list,     :image_button,
		:dd_documentation,     :button,
		:about_dialog_designer, :button
		      ),
	:public)
$

dialog_designer.define_shared_constant(:frame_like_classes,
	{:frame,:dd_tab_box,:dd_group_box,:dd_window_stack},:private)
$
dialog_designer.define_shared_constant(:dialog_xml_,
	{:frame,:dd_tab_box,:dd_group_box,:dd_window_pane},:private)
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.init_actions()
	## 
	## Initialize the actions ...

	dissabled_actions << {:delete_dialog,
			      :delete_element,
			      :paste_element,
			      :cut_element,
			      :copy_element,
			      :radio_item,
			      :reactivate_dialog,
			      :explore_code}

	_for k,e _over _self.action_specs.fast_keys_and_elements()
	_loop
		_if e _is :button
		_then
			_self.add_action(sw_action.new(k,
						       :dialog_control,:button_item,
						       :toolbar_control,:image_button_item,
						       :caption,_self.message(k),
						       :engine,_self,
						       :action_message,k.with_parentheses,
						       :image,{k,_self.module_name}))
		_elif e _is :image_button
		_then
			_self.add_action(sw_action.new(k,
						       :toolbar_control,:image_button_item,
						       :menubar_control,:button_item,
						       :caption,_self.message(k),
						       :engine,_self,
						       :action_message,k.with_parentheses,
						       :image,{k,_self.module_name}))
		_elif e _is :toggle
		_then
			_self.add_action(sw_action.new(k,
						       :toolbar_control,:image_toggle_item,
						       :menubar_control,:toggle_item,
						       :caption,_self.message(k),
						       :engine,_self,
						       :value_change_message,k.with_parentheses,
						       :image,{k,_self.module_name}))
		_elif e _is :widget_toggle
		_then
			_self.add_action(sw_action.new(k,
						       :toolbar_control,:image_toggle_item,
						       :menubar_control,:toggle_item,
						       :caption,_self.message(k),
						       :engine,_self,
						       :value_change_message,{:|set_insertion_mode()|,k},
						       :image,{k,_self.module_name}))
		_elif e _is :text_choice
		_then
			_self.add_action(sw_action.new(k,
						       :toolbar_control,:text_choice_item,
						       :caption,_self.message(k),
						       :engine,_self,
						       :items,_self.perform(k+:|_items()|),
						       :value_change_message,k+:|_value_changed()|,
						       :image,{k,_self.module_name}))
		_elif e _is :text_item
		_then
			_self.add_action(sw_action.new(k,
						       :toolbar_control,:text_item,
						       :caption,_self.message(k),
						       :engine,_self,
						       :value_change_message,k+:|_value_changed()|))
		_endif
	_endloop

	# Dissable some actions.
	_for a _over dissabled_actions.fast_elements()
	_loop
		_self.action(a).enabled? << _false
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.build_gui(f, _optional xml_element )
	##
	## Activate the GUI.
	##

	.items << property_list.new()
	.dialog_list << rope.new()

	rc << rowcol.new(f,_unset,1,:pixel,:style,:nested,
		     :resize?,_true,
		     :default_col_alignment,:fill,
		     :default_row_alignment,:fill)

	.items[:ws] << ws << window_stack.new(rc)

	rc << rowcol.new(ws,_unset,1,:pixel,:style,:nested,
		     :resize?,_true,
		     :default_col_alignment,:fill,
		     :default_row_alignment,:fill)

	.items[:tb] << tb <<
   		   tab_box.new(ws,:resize?, _true,
				    :model,_self,
				    :page_change_selector, :tab_changed|()|)
	tb.name << :tab_box

	_self.gui_layout_tab(tb)
	_self.menubar_tab(tb)
	_self.statusbar_tab(tb)
	_self.docks_tab(tb)
	_self.databus_tab(tb)
	_self.code_tab(tb)
	_self.module_properties_tab(tb)

	>> rc
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.tab_changed(val)
	## 
	## Respond when the tab is changed

	_if val _is 1 
	_then
		_self.set_cursor_status(.items[:current_mode].default(:select_mode))

		_if .canvas _isnt _unset
		_then
			.canvas.set_focus()
		_endif 
	_else
		_self.refresh_magik_xml(val)
		
		msg_key << write_string("prompt_",val).as_symbol()
		_self.framework.update_statusbar(:prompt,:text,_self.message(msg_key))
	_endif

	# SW4 compatibility ... no change_selector available
	_self.diag_types_changed()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.refresh_magik_xml(tab_num,_optional force?)
	## 
	## Force the Magik/XML to refresh when then the user switches
	## to that tab.

	_if tab_num _is 6
	_then
		cla << _self.action(:dialog_class_list).value.write_string
		_self.dialog_class_list_value_changed(cla)

		mth << _self.action(:dialog_method_list).value.write_string
		_self.dialog_method_list_value_changed(mth)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.current_dialog()
	## 
	## Return the current dialog being edited.
	
	_if .items _isnt _unset _andif
	    .items[:current_dialog_i] _isnt _unset _andif
	    .dialog_list _isnt _unset 
	_then
		_return .dialog_list[.items[:current_dialog_i]]
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.gui_layout_tab(tb)
	## 
	## Define the main GUI for placing, dragging and deleting GUI
	## elements of the dialog design.
	
	_local top_rc << rowcol.new(tb,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill,
				:top_spacing,1,
				:left_spacing,1,
				:col_spacing,2,
				:tab_label,_self.message(:gui_layout))

	_self.gui_layout_buttons(top_rc)

	pw << paned_window.new(top_rc,:side_by_side?,_true,
			       :col_resize_values,{100,0})

	rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	a << canvas_agent.new( _unset ) 
	.canvas << scrollable_canvas.new(rc, 300, 200, a,
					 :resize?, _true,
					 :has_vertical_scrollbar?,_true,
					 :has_horizontal_scrollbar?,_true)
	a.define_redraw( :|refresh_view()|,_self)
	a.define_button_press( :|button_pressed()|,_self,:select)
	a.define_button( :|button_released()|,_self,:select)
	a.define_locator( :|changed_mouse_position()|,_self,:move)
	a.define_locator( :|dragged_mouse_position()|,_self,:drag)
	a.define_key({:|set_insertion_mode()|,:select_mode,_true},_self,%space)

	top_rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,2,
				:top_spacing,1,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	.items[:wa_editor] << dd_element_editor.new(:gui_layout)
	.items[:wa_editor].build_gui(top_rc)
	.items[:wa_editor].element_type << :gui_layout
_endmethod
$

# List of actions specifically for the work area, in order.
dialog_designer.define_shared_constant(:gui_layout_actions,
					  {
						  :show_rowcol_cells,
						  :refresh_view,
						  :separator,
						  :copy_element,
						  :paste_element,
						  :cut_element,
						  :select_mode,
						  :separator,
						  :rowcol,
						  :paned_window,
						  :group_box,
						  :radio_group,
						  :tab_box,
						  :window_stack,
						  :separator,
						  :button_item,
						  :label_item,
						  :text_item,
						  :unit_text_item,
						  :radio_item,
						  :toggle_item,
						  :image_button_item,
						  :image_toggle_item,
						  :slider_item,
						  :text_choice_item,
						  :separator,
						  :style_choice_item,
						  :open_file_dir,
						  :plugin_item,
						  :dd_date_time_item,
						  #:dd_spinner_item,
						  :separator,
						  :text_window,
						  :simple_list_item,
						  :tabular_list,
						  :tree_item,
						  :canvas
					  },:private)
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.gui_layout_buttons(rc)
	## 
	## Place the insert-gui-element actions on RC.
	
	_local brc << rowcol.new(rc,_unset,1,:pixel,:style,:nested,
				:resize?,_false,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill,
				:top_spacing,1,
				:row_spacing,-3,
				:col_spacing,0,
				:row_spacing,0,
				:tab_label,_self.message(:gui_layout))

	_for w _over _self.gui_layout_actions.fast_elements()
	_loop
		# Horizontal separator line between groups of 
		_if w _is :separator
		_then
			src << rowcol.new(brc,_unset,1,:pixel,:style,:nested,
					  :left_spacing,-10,
					  :right_spacing,-10)
			p << panel.new(src,_unset,:col_alignment,:fill)
			panel_separator.new(p,:vertical?,_false,:style,:sunken,:width,47)

			irc << _unset 
		_else
			_if irc _is _unset 
			_then
				irc << rowcol.new(brc,_unset,2,:pixel,:style,:nested,
							 :resize?,_false,
							 :row_spacing,0,
							 :col_spacing,0,
							 :top_spacing,0,
							 :bottom_spacing,0)		
			_endif
			
			_self.action(w).place_control_on(irc,:toolbar,:has_border?,_false)	
		_endif
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.menubar_tab(tb)
	## 
	## Define the GUI for menubar manipulation.
	
	pw << paned_window.new(tb,:side_by_side?,_true,
			       :col_resize_values,{100,0},
			       :tab_label,_self.message(:menubar))

	.items[:menubar_tab] << pw

	rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,2,
				:top_spacing,1,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	_local l_style_holder << string_styles_holder.new_with()
	l_style_holder.add_image_scheme(:selected_scheme,
					:default, :closed_folder,
					:selected, {:menubar_pullout,:dialog_desinger})
	
	.items[:menubar] <<
		tree_item.new(rc,
			      :model,        _self,
			      :mode,:one,
			      :allow_dragging_notifier,   :|menubar_allow_dragging?()|,
			      :release_dragging_notifier, :|menubar_release_dragging?()|,

			      :editors,                {{:name, in_place_value_editor}},
			      :edit_on_click?, _true,
			      :edit_start_notifier, :start_editing|()|,
			      :edit_stop_notifier, :stopped_editing|()|,

			      :select_notifier,:|menubar_selection_made()|,
			      :style_holder, l_style_holder, 
			      :aspect,       :menubar_list)
	
	top_rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,2,
				:top_spacing,1,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	.items[:menubar_editor] << dd_element_editor.new(:menubar)
	.items[:menubar_editor].build_gui(top_rc)
	.items[:menubar_editor].element_type << :menubar
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.start_editing(p_tree)
	## 
	## Control tree editing, no edits of separator elements are allowed.
	
	_if p_tree.value[:name] = "-"*30
	_then
		.items[:menubar].agent.stop_edit()
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.stopped_editing(p_tree)
	## 
	## Update the GUI when the user has finished editing the
	## menubar tree.

	.items[:menubar].tree_manager.selection.empty()

	.items[:menubar_editor].edit("")
	.items[:menubar_editor].set_choice_items(_self.menubar_element_list())
	
	.items[:menubar].selection.add(p_tree)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.menubar_elements()
	## 
	## Return a list of the menubar elements.
	
	>> rope.new_from_iter(.items[:menubar].tree_manager,:|fast_trees()|)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.menubar_selection_made(what)
	## 
	## React when a menubar element is selected.
	
	_if (dt << what.an_element()) _is _unset
	_then
		.items[:menubar].popup_menu <<  _unset
		_return 
	_endif

	# Update Menubar Element editor
	.items[:menubar_editor].choose_element(dt.value[:name])

	# Update popup menu
	pm << popup_menu.new(.items[:menubar])
	button_item.new_safe(pm,_self.message(:add_button),_self,{:|modify_menubar()|,{:add_button|()|,dt}})
	_if dt.level _is 2
	_then
		button_item.new_safe(pm,_self.message(:add_menu),_self,{:|modify_menubar()|,{:add_menu|()|,dt}})
	_else
		button_item.new_safe(pm,_self.message(:add_separator),_self,{:|modify_menubar()|,{:add_separator|()|,dt}})
		button_item.new_safe(pm,_self.message(:add_submenu),_self,{:|modify_menubar()|,{:add_submenu|()|,dt}})
	_endif
	
	separator_item.new(pm)
	button_item.new_safe(pm,_self.message(:delete),_self,{:|modify_menubar()|,{:delete_menu|()|,dt}})
	separator_item.new(pm)
	button_item.new_safe(pm,_self.message(:reinit),_self,:init_menubar|()|)

	.items[:menubar].popup_menu << pm
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.init_menubar()
	## 
	## Initialise the menubar.
	
	_self.current_dialog().init_menubar()
	_self.changed(:menubar_list,:refresh)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.init_statusbar()
	## 
	## Initialise the statusbar.
	
	_self.current_dialog().init_statusbar()
	_self.changed(:statusbar_list,:refresh)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.init_docks()
	## 
	## Initialise the docks.
	
	_self.current_dialog().init_docks()
	_self.changed(:docks_list,:refresh)
_endmethod
$

_pragma(classify_level=basic, topic={tree_item}, usage={subclassable})
_method dialog_designer.menubar_allow_dragging?(p_tree, p_row_index, p_col_index,
						   p_selection, p_event, p_default_mouse,
						   _optional p_first_time?)
	## Parameters    : P_TREE: Display tree that has been clicked on (unset
	##                    if it is in the column headings or below
	##                    the last one)
	##                 P_ROW_INDEX: Index in the list of visible
	##                    display trees.
	##                 P_COL_INDEX: Index in the list of columns.
	##                 P_SELECTION: Display tree selection which is
	##                    the current set of selected trees, i.e. the ones that are
	##                    being dragged onto P_TREE.
	##                 P_EVENT: Event that has been raised.
	##                 P_DEFAULT_MOUSE: Depending on modmask of P_EVENT:
	##                    When just Ctrl or Shft are pressed, :copy is the default;
	##                    For Alt or combinations, this is :link; and
	##                    With no modifier, this defaults to :move.
	##                 [P_FIRST_TIME?]: _true if this is the first
	##                    time the dragging notifier is called for
	##                    this drag operation. (This allows to setup caches).
	## Returns       : 1) _false if P_TREE is an invalid destination;
	##                    _true if it is valid, when draggin is allowed
	##                 2) If (1) is _true, then the type of
	##                    dragging that will be done is returned:
	##                    either :copy or :move. 
	## Function      : If P_SELECTION is dragged to a P_TREE on the
	##                 same level, a :move operation is allowed.
	##                 If P_SELECTION is dragged to a P_TREE on a different level,
	##                 this might be a valid copy operation as long as we are not
	##                 trying to copy a tree into itself, and if P_TREE's parent
	##                 does not already contain a child with that key.
	## Function      : If we are dragging P_TREE onto something that is not in P_SELECTION,
	##                 andif non of its parent is in P_SELECTION, 
	##                 dragging is allowed.
	##                 (This is so, since we do not allow a parent to
	##                 become its own child.)
	# we are dragging the selection, and should not be dragged onto itself

	_for i_parent _over p_tree.branch_to_root()
	_loop
		_if i_parent.value _is _unset _then _continue _endif 

		_if i_parent.selected?
		_then
			_return _false 
		_endif
	_endloop

	# Don't allow dropping onto the menu root, only allow dropping
	# below this level.
	_if p_selection.an_element().level _is 2 _andif p_tree.level _is 2
	_then
		_return _true,:move 
	_elif p_selection.an_element().level _is 2 _orif  p_tree.level _is 2
	_then
		_return _false 
	_endif

	# Now check if the new parent already contains a child with
	# this key (only if the new parent is not the same as the
	# current parent)
	_local l_destination_parent << p_tree.parent

	_for i_sel_tree _over p_selection.fast_elements()
	_loop
		_if l_destination_parent _isnt i_sel_tree.parent
		_then
			_leave 
		_endif
	_finally
		# we can move this tree
		_return (_true, :move)
	_endloop
	
	_for i_sel_tree _over p_selection.fast_elements()
	_loop
		_if (l_destination_parent.child_with_key(i_sel_tree.key) _isnt _unset) 
		_then
			_return _false 
		_endif
	_endloop
	
	>> (_true, :move)
_endmethod
$

_pragma(classify_level=basic, topic={tree_item}, usage={subclassable})
_method dialog_designer.menubar_release_dragging?(p_tree, p_row_index, p_col_index, p_selection,
						     _optional p_event, p_default_mouse)
	## Parameters    : P_TREE: Display tree that has been clicked on (unset
	##                    if it is in the column headings or below
	##                    the last one)
	##                 P_ROW_INDEX: Index in the list of visible
	##                    display trees.
	##                 P_COL_INDEX: Index in the list of columns.
	##                 P_SELECTION: Display tree selection which is
	##                    the current set of selected trees, i.e. the ones that are
	##                    being dragged onto P_TREE.
	##                 P_EVENT: Event that has been raised.
	##                 P_DEFAULT_MOUSE: As returned as the second
	##                    argument of the :allow_dragging_notifier.
	##                     When just Ctrl is pressed, :copy is the default;
	##                    For Alt, this is :link; and
	##                    otherwise this defaults to :move.
	##                 [P_FIRST_TIME?]: _true if this is the first
	##                    time the dragging notifier is called for
	##                    this drag operation. (This allows to setup caches).
	## Returns       : -
	## Function      : If P_SELECTION is dragged to a P_TREE on the
	##                 same level, all display_trees in P_SELECTION are first detached,
	##                 then attached again to P_TREE's parent at the right position below P_TREE.
	##                 If P_SELECTION is dragged to a P_TREE on a different level,
	##                 the trees in P_SELECTION are all copied (including complete substructure).
	# The move operation is is a simplification of the release
	# dragging implemented on tree_agent, which deals with dragging
	# a (>1)-size selection in a better/safer way.

	#show(p_tree, p_row_index, p_col_index, p_selection, p_event, p_default_mouse)
	
	_if (p_tree _is _unset) _then _return _endif

	_local l_destination_parent << p_tree.parent
	_local l_destination_index << l_destination_parent.index_of_child(p_tree)
	_dynamic !updating_trees?! << _true

	_if p_selection.an_element().level _is 2 _andif
	    p_tree.level _is 2
	_then
		_self.current_dialog().move_menu(p_selection.an_element(),p_tree)
	_else 
		
		_for i_sel_tree _over p_selection.fast_elements()
		_loop
			p_sel_tree << i_sel_tree.parent
			pp_sel_tree << i_sel_tree.parent.parent
			
			i_sel_tree.detach()
			l_destination_parent.add_child(i_sel_tree, l_destination_index +^<< 1)
			
			_if p_sel_tree.children.empty?
			_then
				pp_sel_tree.remove_child(p_sel_tree)
			_endif 	
		_endloop
	_endif 

	!updating_trees?! << _false

	# now redraw
	_self.changed(:menubar_list,:refresh)
_endmethod
$



_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.modify_menubar(args)
	## 
	## Modify the menubar.

	_self.current_dialog().perform(_scatter args)

	_self.changed(:menubar_list,:refresh)
	.items[:menubar].tree_manager.selection.empty()

	.items[:menubar_editor].edit("")
	.items[:menubar_editor].set_choice_items(_self.menubar_element_list())

	_self.update_gui_for_dialog()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.menubar_list
	## 
	## Return a list of menubar elements suitable for the dd_element_editor.

	_if (d << _self.current_dialog()) _isnt _unset
	_then
		_return d.menubar
	_endif 

	_return rope.new()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.statusbar_tab(tb)
	## 
	## Define the GUI for maniplating the statusbar.
	
	pw << paned_window.new(tb,:side_by_side?,_true,
			       :col_resize_values,{100,0},
			       :tab_label,_self.message(:statusbar))

	.items[:statusbar_tab] << pw

	top_rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,2,
				:top_spacing,1,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	rc << rowcol.new(top_rc,_unset,1,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,1,	
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	a << canvas_agent.new( _unset ) 
	.items[:statusbar_canvas] <<
		scrollable_canvas.new(rc, 300, 26, a,
				      :resize?, _true,
				      :has_vertical_scrollbar?,_false )
	
	a.define_redraw( :|refresh_statusbar()|,_self)
	a.define_button( :|statusbar_canvas_button_pressed()|,_self,:select)
	
	_local l_style_holder << string_styles_holder.new_with()
	l_style_holder.add_image_scheme(:selected_scheme,
					:default, :closed_folder,
					:selected, {:menubar_pullout,:dialog_desinger})
	
	.items[:statusbar] <<
		tree_item.new(rc,
			      :model,        _self,
			      :mode,:one,
			      :allow_dragging_notifier,   :|statusbar_allow_dragging?()|,
			      :release_dragging_notifier, :|statusbar_release_dragging?()|,
			      :select_notifier,:|statusbar_selection_made()|,
			      :style_holder, l_style_holder, 
			      :aspect,       :statusbar_list)

	top_rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,2,
				:top_spacing,1,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	.items[:statusbar_editor] << dd_element_editor.new(:statusbar)
	.items[:statusbar_editor].build_gui(top_rc)
	.items[:statusbar_editor].element_type << :statusbar
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_statusbar_list_popup(what)
	## 
	## Set the popup menu for the statusbar list.
	
	_if (dt << what.an_element()) _is _unset
	_then
		.items[:statusbar].popup_menu <<  _unset
		_return 
	_endif

	pm << popup_menu.new(.items[:statusbar])
	
	button_item.new_safe(pm,_self.message(:add_status_pane),_self,{:|modify_statusbar()|,{:add_status_pane|()|,dt.key}})
	
	separator_item.new(pm)
	button_item.new_safe(pm,_self.message(:delete_status_pane),_self,{:|modify_statusbar()|,{:delete_status_pane|()|,dt.key}})
	separator_item.new(pm)
	button_item.new_safe(pm,_self.message(:reinit),_self,:init_statusbar|()|)

	.items[:statusbar].popup_menu << pm
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.statusbar_canvas_button_pressed(x,y)
	## 
	## React when the select button is pressed in statusbar canvas,
	## change the currently selected statusbar element if necessary.

	_if (d << _self.current_dialog()) _is _unset _orif
	    (sb << d.statusbar) _is _unset
	_then
		_return 
	_endif

	_if (i << d.element_at(x,y)) _isnt _unset
	_then 
		.items[:statusbar].selection.add(.items[:statusbar].tree_manager.data[i])
	_endif 
	
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.statusbar_selection_made(what)
	## 
	## React when the user selects from the list of statusbar
	## panes, update the status bar canvas render.
	
	_self.set_statusbar_list_popup(what)
	
	_if (dt << what.an_element()) _is _unset
	_then
		_self.refresh_statusbar()
		_return 
	_endif

	.items[:statusbar_editor].choose_element(dt.value[:id])

	_self.refresh_statusbar()

_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.modify_statusbar(args)
	## 
	## Perform ARGS on the current dialog and update the GUI.

	_self.current_dialog().perform(_scatter args)

	.items[:statusbar].tree_manager.selection.empty()
	_self.changed(:statusbar_list,:refresh)

	.items[:statusbar_editor].set_choice_items(_self.statusbar_element_list())

	_self.refresh_statusbar()

	_self.update_gui_for_dialog()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.statusbar_list
	## 
	## Return a list of statusbar elements suitable for the dd_element_editor.

	rp << rope.new()

	_if (d << _self.current_dialog()) _is _unset _orif
	    (sb << d.statusbar) _is _unset
	_then
		_return rp
	_endif

	cnt << 0

	_for i _over 1.upto(sb.size)
	_loop
		p << sb[i]

		dt << display_tree.new(cnt+<<1,p.values)
		dt.styled_string << {:value, :id}

		rp.add(dt)
	_endloop

	>> rp
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.refresh_statusbar()
	## 
	## Refresh the graphic render of the statusbar.

	c << .items[:statusbar_canvas]

	c.clear()

	_if (d << _self.current_dialog()) _is _unset _orif
	    (sb << d.statusbar) _is _unset
	_then
		_return 
	_endif

	css << .items[:statusbar].selection.an_element()
	
	d.render_statusbar(c,0,4,4,css)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.statusbar_element_list()
	## 
	## Return a list of statusbar elements suited to the choice
	## item of the dd_element_editor.
	
	_if (d << _self.current_dialog()) _isnt _unset 
	_then
		_return d.statusbar_element_list()
	_endif 
_endmethod
$



_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.statusbar_allow_dragging?()
	## 
	## Allow dragging of statusbar elements.
	
	>> _true,:move
_endmethod
$
_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.statusbar_release_dragging?(p_tree, p_row_index, p_col_index, p_selection,
						_optional p_event, p_default_mouse)
	## 
	## Control statusbar dragging and update the statusbars render.

	_if (d << _self.current_dialog()) _is _unset _orif
	    (sb << d.statusbar) _is _unset
	_then
		_return 
	_endif

	from_i << p_selection.an_element().key
	to_i << p_row_index

	_if to_i > from_i
	_then
		to_i -<< 1
	_endif

	from << sb[from_i].deep_copy()
	sb.remove_nth(from_i)
	sb.add_nth(from,to_i)

	# now redraw
	_self.changed(:statusbar_list,:refresh)
	_self.refresh_statusbar()

	.items[:statusbar].selection.empty()
	.items[:statusbar].selection.add(.items[:statusbar].tree_manager.data[to_i])
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.docks_tab(tb)
	## 
	## Define the GUI for manipulating dock elements.
	
	pw << paned_window.new(tb,:side_by_side?,_true,
			       :col_resize_values,{100,0},
			       :tab_label,_self.message(:docks))

	.items[:docks_tab] << pw

	rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,2,
				:top_spacing,1,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	.items[:docks] <<
		tree_item.new(rc,
			      :model,        _self,
			      :mode,:one,
			      :allow_dragging_notifier,   :|dock_allow_dragging?()|,
			      :release_dragging_notifier, :|dock_release_dragging?()|,

			      :editors,                {{:name, in_place_value_editor}},
			      :edit_on_click?, _true,
			      :edit_start_notifier, :start_dock_editing|()|,
			      :edit_stop_notifier, :stopped_dock_editing|()|,

			      :select_notifier,:|dock_selection_made()|,
			      :aspect,       :docks_list)
	
	top_rc << rowcol.new(pw,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:row_spacing,2,
				:top_spacing,1,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill)
	
	.items[:docks_editor] << dd_element_editor.new(:dock)
	.items[:docks_editor].build_gui(top_rc)
	.items[:docks_editor].element_type << :docks

	>> pw
	
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.start_dock_editing(p_tree)
	## 
	## Control dock editing, do not allow the top_level docks to be
	## changed as they are system constant (:top,:bottom,:right,:left)
	
	_if p_tree.level _is 2
	_then
		.items[:docks].agent.stop_edit()
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.stopped_dock_editing(p_tree)
	## 
	## Update the GUI when the dock tree is modified.

	.items[:docks].tree_manager.selection.empty()

	.items[:docks_editor].edit("")
	.items[:docks_editor].set_choice_items(_self.docks_element_list())
	
	.items[:docks].selection.add(p_tree)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.dock_selection_made(what)
	## 
	## React when an element of the dock is selected.

	_if (dt << what.an_element()) _is _unset
	_then
		.items[:docks].popup_menu <<  _unset
		_return 
	_endif

	# Update Docks Element editor
	.items[:docks_editor].choose_element(dt.value[:name])

	# Update popup menu
	pm << popup_menu.new(.items[:docks])

	_if dt.level _is 2
	_then
		_if dt.children.an_element() _isnt _unset
		_then
			button_item.new_safe(pm,_self.message(:add_section),
					     _self,{:|modify_docks()|,{:add_section|()|,dt}})
		_else
			button_item.new_safe(pm,_self.message(:add_action),
					     _self,{:|modify_docks()|,{:add_action|()|,dt}})	
		_endif
	_elif dt.level _is 3 
	_then
		button_item.new_safe(pm,_self.message(:add_toolbar),
				     _self,{:|modify_docks()|,{:add_toolbar|()|,dt}})
	_elif dt.level _is 4
	_then
		button_item.new_safe(pm,_self.message(:add_action),
				     _self,{:|modify_docks()|,{:add_action|()|,dt}})
	_endif
	
	_if dt.level > 2
	_then
		_if dt.level < 5
		_then
			separator_item.new(pm)		
		_endif
		
		button_item.new_safe(pm,_self.message(:delete),_self,{:|modify_docks()|,{:delete_dock_element|()|,dt}})
	_endif 

	separator_item.new(pm)
	button_item.new_safe(pm,_self.message(:reinit),_self,:init_docks|()|)
	
	.items[:docks].popup_menu << pm
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.docks_list
	## 
	## Return a list suited to the dd_element_editor.
	
	_if (d << _self.current_dialog()) _isnt _unset 
	_then
		_return d.docks
	_endif

	>> rope.new()
_endmethod
$

_pragma(classify_level=basic, topic={tree_item}, usage={subclassable})
_method dialog_designer.dock_allow_dragging?(p_tree, p_row_index, p_col_index,
						   p_selection, p_event, p_default_mouse,
						   _optional p_first_time?)
	## Parameters    : P_TREE: Display tree that has been clicked on (unset
	##                    if it is in the column headings or below
	##                    the last one)
	##                 P_ROW_INDEX: Index in the list of visible
	##                    display trees.
	##                 P_COL_INDEX: Index in the list of columns.
	##                 P_SELECTION: Display tree selection which is
	##                    the current set of selected trees, i.e. the ones that are
	##                    being dragged onto P_TREE.
	##                 P_EVENT: Event that has been raised.
	##                 P_DEFAULT_MOUSE: Depending on modmask of P_EVENT:
	##                    When just Ctrl or Shft are pressed, :copy is the default;
	##                    For Alt or combinations, this is :link; and
	##                    With no modifier, this defaults to :move.
	##                 [P_FIRST_TIME?]: _true if this is the first
	##                    time the dragging notifier is called for
	##                    this drag operation. (This allows to setup caches).
	## Returns       : 1) _false if P_TREE is an invalid destination;
	##                    _true if it is valid, when draggin is allowed
	##                 2) If (1) is _true, then the type of
	##                    dragging that will be done is returned:
	##                    either :copy or :move. 
	## Function      : If P_SELECTION is dragged to a P_TREE on the
	##                 same level, a :move operation is allowed.
	##                 If P_SELECTION is dragged to a P_TREE on a different level,
	##                 this might be a valid copy operation as long as we are not
	##                 trying to copy a tree into itself, and if P_TREE's parent
	##                 does not already contain a child with that key.
	## Function      : If we are dragging P_TREE onto something that is not in P_SELECTION,
	##                 andif non of its parent is in P_SELECTION, 
	##                 dragging is allowed.
	##                 (This is so, since we do not allow a parent to
	##                 become its own child.)
	# we are dragging the selection, and should not be dragged onto itself

	_for i_parent _over p_tree.branch_to_root()
	_loop
		_if i_parent.selected?
		_then
			_return _false 
		_endif
	_endloop

	# No dragging tree roots (keeps the top,bottom,left,right order)
	_if p_tree.level _is 2 _orif p_tree.level <> p_selection.an_element().level
	_then 
		_return _false 
	_endif

	# now check if the new parent already contains a child with
	# this key (only if the new parent is not the same as the
	# current parent)
	_local l_destination_parent << p_tree.parent

	_for i_sel_tree _over p_selection.fast_elements()
	_loop
		_if l_destination_parent _isnt i_sel_tree.parent
		_then
			_leave 
		_endif
	_finally
		# we can move this tree
		_return (_true, :move)
	_endloop
	
	_for i_sel_tree _over p_selection.fast_elements()
	_loop
		_if (l_destination_parent.child_with_key(i_sel_tree.key) _isnt _unset) 
		_then
			_return _false 
		_endif
	_endloop
	>> (_true, :move)
_endmethod
$

_pragma(classify_level=basic, topic={tree_item}, usage={subclassable})
_method dialog_designer.dock_release_dragging?(p_tree, p_row_index, p_col_index, p_selection,
						     _optional p_event, p_default_mouse)
	## Parameters    : P_TREE: Display tree that has been clicked on (unset
	##                    if it is in the column headings or below
	##                    the last one)
	##                 P_ROW_INDEX: Index in the list of visible
	##                    display trees.
	##                 P_COL_INDEX: Index in the list of columns.
	##                 P_SELECTION: Display tree selection which is
	##                    the current set of selected trees, i.e. the ones that are
	##                    being dragged onto P_TREE.
	##                 P_EVENT: Event that has been raised.
	##                 P_DEFAULT_MOUSE: As returned as the second
	##                    argument of the :allow_dragging_notifier.
	##                     When just Ctrl is pressed, :copy is the default;
	##                    For Alt, this is :link; and
	##                    otherwise this defaults to :move.
	##                 [P_FIRST_TIME?]: _true if this is the first
	##                    time the dragging notifier is called for
	##                    this drag operation. (This allows to setup caches).
	## Returns       : -
	## Function      : If P_SELECTION is dragged to a P_TREE on the
	##                 same level, all display_trees in P_SELECTION are first detached,
	##                 then attached again to P_TREE's parent at the right position below P_TREE.
	##                 If P_SELECTION is dragged to a P_TREE on a different level,
	##                 the trees in P_SELECTION are all copied (including complete substructure).
	# The move operation is is a simplification of the release
	# dragging implemented on tree_agent, which deals with dragging
	# a (>1)-size selection in a better/safer way.

	#show(p_tree, p_row_index, p_col_index, p_selection, p_event, p_default_mouse)
	
	_if (p_tree _is _unset) _then _return _endif

	_local l_destination_parent << p_tree.parent
	_local l_destination_index << l_destination_parent.index_of_child(p_tree)
	_dynamic !updating_trees?! << _true
	
	_for i_sel_tree _over p_selection.fast_elements()
	_loop
		p_sel_tree << i_sel_tree.parent
		pp_sel_tree << i_sel_tree.parent.parent

		i_sel_tree.detach()
		l_destination_parent.add_child(i_sel_tree, l_destination_index +^<< 1)

		_if p_sel_tree.children.empty?
		_then
			pp_sel_tree.remove_child(p_sel_tree)
		_endif 	
	_endloop

	_if p_selection.an_element().level _is 2 _andif
	    p_tree.level _is 2
	_then
		_self.current_dialog().move_menu(p_selection.an_element(),p_tree)
	_endif
	
	!updating_trees?! << _false

	# now redraw
	_self.changed(:docks_list,:refresh)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.modify_docks(args)
	## 
	## Perform ARGS on the current dialog and then update the GUI.

	_self.current_dialog().perform(_scatter args)

	_self.changed(:docks_list,:refresh)
	.items[:docks].tree_manager.selection.empty()

	.items[:docks_editor].edit("")
	.items[:docks_editor].set_choice_items(_self.docks_element_list())

	_self.update_gui_for_dialog()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.databus_tab(tb)
	## 
	## Define the GUI for specifying the producer and consumer
	## datatypes for the design.
	
	rowcol_01 << rowcol.new(tb,3,2,:pixel,
		:resize?,	_true,
		:bottom_spacing,	6,
		:col_resize_values,	{50,50},
		:col_spacing,	7,
		:default_col_alignment,	:fill,
		:default_row_alignment,	:fill,
		:left_spacing,	6,
		:right_spacing,	6,
		:row_resize_values,	{0,50,50},
		:row_spacing,	6,
		:tab_label,       _self.message(:databus),
		:top_spacing,	6)

	rowcol_02 << rowcol.new(rowcol_01,1,3,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:col,	1,
		:col,	1,
		:col_resize_values,	{0,100,0},
		:col_spacing,	0,
		:col_alignment,	:fill,
		:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:row,	1,
		:row,	1,
		:row_spacing,	6,
		:top_spacing,	0)

	label_item.new(rowcol_02,_self.message(:app),:row,1,:col,1)
	.items[:app_list] << text_choice_item.new(rowcol_02,"",
			:model,   _self,
			:items,   _self.app_list,
			:change_selector, :|update_app_pro_con_lists()|,
			:col,	2,
			:col_alignment,	:fill,
			:row,	1,
			:row_alignment,	:top )

	_self.action(:refresh_app_list).place_control_on(rowcol_02,:dialog,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	3,
			:col_alignment,	:right,
			:row,	1,
			:row_alignment,	:top} )

	gb << group_box.new(rowcol_01,_self.message(:app_produced_data_types),:row,2,:col,1)

	dd_group_box_01 << rowcol.new(gb,1,1,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:default_col_alignment,	:fill,
		:default_row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:top_spacing,	0)

	.items[:app_pro_types] << simple_list_item.new(dd_group_box_01,
			:col,	1,
			:col_alignment,	:fill,
			:width,   50,
			:mode, :many,
			:row,	1,
			:row_alignment,	:fill,
			:height,   50)
	
	.items[:app_pro_types].menu << _self.appcon_popup(:app_pro_types)

	gb << group_box.new(rowcol_01,_self.message(:dialog_consumed_data_types),:row,2,:col,2)

	dd_group_box_03 << rowcol.new(gb,1,1,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:default_col_alignment,	:fill,
		:default_row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:top_spacing,	0)

	.items[:diag_con_types] << text_window.new(dd_group_box_03,_unset,_unset,_unset,
# SW4.1 only		:change_selector,  :|diag_types_changed()|,
			:col,	1,
			:col_alignment,	:fill,
			:cols,	20,
			:editable?,	_true,
			:font_size,	12,
			:horizontal_scrollbar?,	_false,
			:row,	1,
			:row_alignment,	:fill,
			:rows,	6,
			:vertical_scrollbar?,	_true )

	gb << group_box.new(rowcol_01,_self.message(:app_consumed_data_types),:row,3,:col,1)

	dd_group_box_02 << rowcol.new(gb,1,1,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:default_col_alignment,	:fill,
		:default_row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:top_spacing,	0)

	.items[:app_con_types] << simple_list_item.new(dd_group_box_02,
			:col,	1,
			:col_alignment,	:fill,
			:width,   50,
			:row,	1,
			:mode, :many,
			:row_alignment,	:fill,
			:height,   50)

	.items[:app_con_types].menu << _self.appcon_popup(:app_con_types)

	gb << group_box.new(rowcol_01,_self.message(:dialog_produced_data_types),:row,3,:col,2)

	dd_group_box_04 << rowcol.new(gb,1,1,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:default_col_alignment,	:fill,
		:default_row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:top_spacing,	0)

	.items[:diag_pro_types] << text_window.new(dd_group_box_04,_unset,_unset,_unset,
# SW4.1 only		:change_selector,  :|diag_types_changed()|,
			:col,	1,
			:col_alignment,	:fill,
			:cols,	20,
			:editable?,	_true,
			:font_size,	12,
			:horizontal_scrollbar?,	_false,
			:row,	1,
			:row_alignment,	:fill,
			:rows,	6,
			:vertical_scrollbar?,	_true )

_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.appcon_popup(which)
	## 
	## Set the popup for WHICH application data types list.
	pm << popup_menu.new(.items[which])

	button_item.new_safe(pm,_self.message(:add_to_list),
			     _self,{:|add_datatypes()|,which})

	button_item.new_safe(pm,_self.message(:remove_from_list),
			     _self,{:|remove_datatypes()|,which})
	>> pm
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.add_datatypes(which)
	## 
	## Add selected datatypes (in WHICH item) to corresponding
	## Dialog dataypes list.
	## 
	target << _if which _is :app_con_types
		  _then
			  >> :diag_pro_types
		  _else 
			  >> :diag_con_types
		  _endif

	sp << .items[target].contents.default("").split_by(%newline)

	txt << .items[target].contents.write_string

	sel << .items[which].selected_items

	_for s _over sel.fast_elements()
	_loop
		_if sp.index_equal_of(s) _is _unset 
		_then
			txt +<< write_string(s,%newline)
		_endif
	_endloop

	.items[target].contents << txt
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.remove_datatypes(which)
	## 
	## Remove selected datatypes (in WHICH item) from corresponding
	## Dialog dataypes list.
	
	target << _if which _is :app_con_types
		  _then
			  >> :diag_pro_types
		  _else 
			  >> :diag_con_types
		  _endif

	sp << .items[target].contents.default("").split_by(%newline)

	txt << ""

	sel << .items[which].selected_items

	_for s _over sp.fast_elements()
	_loop
		_if sel.index_equal_of(s) _is _unset 
		_then
			txt +<< write_string(s,%newline)
		_endif
	_endloop

	.items[target].contents << txt
_endmethod
$



_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.app_list
	## 
	## Return the list of currently running SW applications, if any.
	
	rp << rope.new()

	_for a _over smallworld_product.applications.fast_elements()
	_loop
		rp.add({a.application_name,a.external_name})
	_endloop

	_if rp.empty?
	_then
		rp.add({:none,_self.message(:no_app_running)})
	_endif

	>> rp
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.refresh_app_list()
	## 
	## Refresh the list of applications, necessary as the user can
	## open and close applications anytime.
	
	.items[:app_list].items << _self.app_list
	_self.update_app_pro_con_lists()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.update_app_pro_con_lists()
	## 
	## Update the listed datatypes that the chosen application
	## produces and consumes.
	
	_if (app_name << .items[:app_list].value) _is :none _orif
	    smallworld_product.application(app_name) _is _unset 
	_then
		.items[:app_con_types].items << {"None"}
		.items[:app_pro_types].items << {"None"}
	_else
		db << smallworld_product.application(app_name).databus
		cm << db.sys!slot(:consumer_manager)
		pm << db.sys!slot(:producer_manager)

		# App Consumer data types
		deps << set.new()
		_for p _over cm.dependencies()
		_loop
			deps.add(p)
		_endloop

		s_deps << sorted_collection.new_with(_scatter deps)

		items << rope.new()
		_for d _over s_deps.fast_elements()
		_loop
			items.add_last(write_string(d))
		_endloop
		
		.items[:app_con_types].items << items

		# App Producer Data Types
		# Usually the Consumer and Producer Data Types are the same but
		# they MAY be different, so we have to compile separately
		deps << set.new()
		_for p _over pm.dependencies()
		_loop
			deps.add(p)
		_endloop

		s_deps << sorted_collection.new_with(_scatter deps)

		items << rope.new()
		_for d _over s_deps.fast_elements()
		_loop
			items.add_last(write_string(d))
		_endloop
		
		.items[:app_pro_types].items << items
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.diag_types_changed()
	## 
	## Update the producer and consumers types for the dialog when
	## they are modified in the GUI.

	_if .items[:diag_con_types] _is _unset _orif
	    .items[:diag_pro_types] _is _unset _then _return _endif 

	cons << .items[:diag_con_types].contents
	pros << .items[:diag_pro_types].contents

	cons.substitute_character(%newline,%,)
	cons.substitute_character(% ,%,)
	
	pros.substitute_character(%newline,%,)
	pros.substitute_character(% ,%,)

	_self.current_dialog().databus[:produce] << pros
	_self.current_dialog().databus[:consume] << cons
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.use_databus(val)
	## 
	## Make the databus tab visible if VAL=TRUE else hide it.

	_dynamic !switching_dialogs?!
	_if !switching_dialogs?!.default(_false)
	_then
		_return 
	_endif
	
	_if val
	_then
		.items[:tb].pages[5].manage()
		.items[:tb].active_page << .items[:tb].pages[5]
		_self.tab_changed(5)
	_else 
		.items[:tb].pages[5].unmanage()
	_endif

	_self.current_dialog().use_databus? << val

	_self.changed(:databus_list,:refresh)
	_self.refresh_view()

	_self.update_gui_for_dialog()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.modify_databus(args)
	## 
	## Perform ARGS on the current dialog.

	_self.current_dialog().perform(_scatter args)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.refresh_databus()
	## 
	## Set the databus datatypes listed with those from the
	## current dialog.
	
	db << _self.current_dialog().databus()
	pros << db[:produce].default("").write_string.split_by(%,)
	cons << db[:consume].default("").write_string.split_by(%,)

	# remove empty rows from the list
	pros_txt << ""
	_for a _over pros.fast_elements()
	_loop
		pros_txt +<< write_string(a,%newline)
	_endloop
	
	cons_txt << ""
	_for a _over cons.fast_elements()
	_loop
		cons_txt +<< write_string(a,%newline)
	_endloop

	.items[:diag_pro_types].contents << pros_txt
	.items[:diag_con_types].contents << cons_txt
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.code_tab(tb)
	## 
	## Define the GUI for displaying the Magik and XML that is
	## going to be generated for the current dialog.  This GUI
	## allows the user to preview the code before generating any.
	##
	## The Dialog Designer can be used this way to generate code
	## snippets ready for inclusion in existing dialogs.
	
	_local rc << rowcol.new(tb,_unset,1,:pixel,:style,:nested,
				:resize?,_true,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill,
				:top_spacing,1,
				:row_spacing,1,
				:tab_label,_self.message(:code))
	.items[:magik_xml] << rc

	rc1 << rowcol.new(rc,1,_unset,:pixel,:style,:nested,
				:resize?,_true,
				:col_spacing,0,
				:default_col_alignment,:left,
				:default_row_alignment,:fill)

	_self.action(:dialog_class_list).place_control_on(rc1,:dialog)
	_self.action(:dialog_method_list).place_control_on(rc1,:dialog)
	_self.action(:explore_code).place_control_on(rc1,:dialog,:has_border?,_false)

	.items[:dialog_class_method] <<
		text_window.new(rc,_unset,_unset,_unset,
				:col_alignment, :fill,
				:row_alignment, :fill,
				:font,font.new_with_properties(:type,:logical,:name,"fixed",:point_size,12),
				:editable?,_false)
	
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.dialog_class_list_items()
	## 
	## Return the list of classes for the current dialog.

	>> _if (d << _self.current_dialog()) _isnt _unset
	   _then
		   >> rope.new_with(d.dialog_class,
				    d.dialog_class+"_framework",
				    d.dialog_class+"_plugin",
				    "XML")
	   _else
		   >> rope.new()
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.dialog_class_list_value_changed(val)
	## 
	## React when a different class is selected. The list of
	## methods and the displayed code is updated.

	val << _self.action(:dialog_method_list).value.deep_copy()
	its << _self.action(:dialog_method_list).items << _self.dialog_method_list_items()
	
	_self.dialog_method_list_value_changed(its.an_element())

	_self.clear_selection_bb(_true)

	_try
		_self.action(:dialog_method_list).set_value(val)
	_when error
	_endtry 
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.dialog_method_list_items()
	## 
	## Return a list of methods suitable to the method list choice item.
	
	>> _if (a_class << _self.action(:dialog_class_list).value) _isnt _unset 
	   _then
		   >> _self.current_dialog().class_methods(a_class)
	   _else
		   >> rope.new()
	   _endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.dialog_method_list_value_changed(meth)
	## 
	## Update the displayed code when METH is chosen from the
	## method choice list.

	.items[:dialog_class_method].contents <<
		_if (d << _self.current_dialog()) _isnt _unset _andif
		    (a_class << _self.action(:dialog_class_list).value) _isnt _unset 
		_then
			_dynamic window_stack_driver_methods << d.window_stack_driver_methods()

			>> d.dialog_method(a_class,meth.as_symbol())
		_else
			>> ""
		_endif 
		
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.validate_class_name(str)
	## 
	## Validate the potential dialog_class STR.  Substitutes
	## underscores for spaces, removes non-alpha-numerics (except
	## underscore) and changes to lowercase.  A valide class name
	## is returned as a char16_vector.

	str << str.lowercase.substitute_character(% ,%_)
	
	new_str << ""
	alpha << "_abcdefghijklmnopqrstuvwxyz0123345679"
	
	_for i _over 1.upto(str.size)
	_loop
		_if alpha.index_of(str[i]) _isnt _unset 
		_then
			new_str +<< str[i]
		_endif
	_endloop

	>> new_str
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.change_dialog(what)
	## 
	## React to a change in a dialog property.

	# Validate uniqueness of new dialog_class entry.
	_if what _is :dialog_class 
	_then
		new_class << _self.validate_class_name(.items[what].value)
		.items[what].value << new_class
		
		_if new_class <> _self.current_dialog().dialog_class _andif
		    _self.used_dialog_class?(new_class) 
		_then
			_if .items[:alert_down?].default(_true)
			_then
				.items[:alert_down?] << _false 
				_self.show_alert(_self.message(:warning_used_dialog_class,new_class))
				.items[what].value << _self.current_dialog().dialog_class
				
				.items[:alert_down?] << _true 
			_endif

			_return 
		_endif

		name_ver << .items[:build_module_name].value.split_by(% )
		.items[:build_module_name].value << write_string(new_class," ",name_ver[2])

		.items[:pragma_topic].value << write_string(new_class)
		_self.current_dialog().pragma_topic <<  write_string(new_class)
		_self.change_dialog(:build_module_name)

	_elif what _is :build_module_name
	_then
		name_ver << ""
		val << .items[what].value.default("")

		_for i _over 1.upto(val.size)
		_loop
			_if val[i].ascii_alphanumeric? _orif
			    val[i] _is %  _orif val[i] _is %_
			_then
				name_ver +<< val[i].lowercase
			_endif
		_endloop
		
		sp << name_ver.split_by(% )

		_if sp.size _isnt 2
		_then
			_return _self.show_alert(_self.message(:invalid_module_name_and_version))
		_endif
		
		val << "\" + sp.first.lowercase  #"
		
		.items[:build_module_name_for_dir].value << val
		.items[what].value << name_ver.lowercase
	_endif

	# Ensure the package name is valid
	.items[:dialog_package].value << .items[:dialog_package].value.lowercase

	# Update the list of dialogs
	_self.current_dialog().perform(what.with_chevron,.items[what].value)
	_self.action(:dialog_list).items << _self.dialog_list_items()

	# Update the dialog class list
	_self.action(:dialog_class_list).items << _self.dialog_class_list_items()
	_self.dialog_class_list_value_changed(_self.action(:dialog_class_list).value)

	_self.update_titlebar()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.module_properties_tab(tb)
	## 
	## Define the GUI for modifying module properties.
	
	_local top_rc << rowcol.new(tb,2,2,:pixel,:style,:nested,
				:resize?,_true,
				:default_col_alignment,:fill,
				:default_row_alignment,:fill,
				:top_spacing,1,
				:left_spacing,0,
				:col_resize_values,{100,0},
				:tab_label,_self.message(:build))
	.items[:build_module] << top_rc

	# BASE CLASS Group Box.
	.items[:properties_gb1] <<
	bm_gb << group_box.new(top_rc,_self.message(:base_class_def),
			       :col_alignment,:fill,
			       :row_alignment,:top,
			       :row,1,:col,1,
			       :resize_y?,_false,
			       :max_height,108)

	bm_rc << rowcol.new(bm_gb,_unset,2,:pixel,
			  :style,:group_box,
			  :resize_x?,_true,
			  :default_col_alignment,:fill,
			  :col_spacing,0,
			  :col_resize_values,{0,100},
			  :default_row_alignment,:top,
			  :bottom_spacing,0)
	# Base Class 
	label_item.new(bm_rc,_self.message(:dialog_class))

	bcrc << rowcol.new(bm_rc,1,_unset,:pixel,
			  :style,:nested,:resize?,_true,
			  :col_spacing,0,
			  :default_col_alignment,:fill,
			  :col_resize_values,{100,0,0})
	
	.items[:dialog_class] <<
		text_item.new(bcrc,_unset,
			      :model,_self,
			      :width, 200,
			      :value,_self.message(:dialog_class_default),
			      :change_selector,{:change_dialog|()|,:dialog_class},
			      :activate_selector,{:change_dialog|()|,:dialog_class})
	
	# Package definition
	label_item.new(bcrc," "*10 + _self.message(:dialog_package),:col_alignment,:right)
	.items[:dialog_package] <<
		combo_box_item.new(bcrc,_unset,
				     :items,rope.new_from_iter(package.all_packages,:|fast_keys()|),
				     :value,package.all_packages.an_element().name,
				     :min_width,100,
				     :model,_self,
				     :incremental_change_selector,{:change_dialog|()|,:dialog_package},
				     :balloon_help_text,_self.message(:dialog_package_tt))
	
	# Base Class extra slots
	label_item.new(bm_rc,_self.message(:dialog_extra_slots))
	.items[:dialog_extra_slots] <<
		text_item.new(bm_rc,_unset,:value,"",
			      :model,_self,
			      :balloon_help_text,_self.message(:dialog_extra_slots_tt),
			      :change_selector,{:change_dialog|()|,:dialog_extra_slots},
			      :activate_selector,{:change_dialog|()|,:dialog_extra_slots})
	
	# Pragma Classification input
	label_item.new(bm_rc,_self.message(:dialog_pragma))

	prc << rowcol.new(bm_rc,1,_unset,:pixel,
			  :style,:nested,:resize?,_true,
			  :col_spacing,2,
			  :default_col_alignment,:fill,
			  :col_resize_values,{0,0,100})
	
	.items[:pragma_classify_level] <<
		text_choice_item.new(prc,_unset,
				     :items,{"basic",
					     "advanced",
					     "restricted",
					     "debug",
					     "deprecated"},
				     :value,"restricted",
				     :model,_self,
				     :change_selector,{:change_dialog|()|,:pragma_classify_level},
				     :balloon_help_text,_self.message(:pragma_classify_level_tt))
					     
	.items[:pragma_usage] <<
		combo_box_item.new(prc,_unset,
				     :items,{"",
					     "internal",
					     "external",
					     "input",
					     "output"},
				     :min_width,100,
				     :model,_self,
				     :incremental_change_selector,{:change_dialog|()|,:pragma_usage},
				     :balloon_help_text,_self.message(:pragma_usage_tt))

	.items[:pragma_topic] <<
		text_item.new(prc,_unset,:value,"",
			      :model,_self,
			      :value,"default_class",
			      :resize?,_true,
			      :model,_self,
			      :change_selector,{:change_dialog|()|,:pragma_topic},
			      :activate_selector,{:change_dialog|()|,:pragma_topic},
			      :balloon_help_text,_self.message(:pragma_topic_tt))
	
	# MODULE PROPERTIES Group Box.
	bm_gb2 << group_box.new(top_rc,_self.message(:build_module_def),
				:row,2,:col,1,
				:col_alignment,:fill,
				:row_alignment,:fill)
	
	bm_rc1 << rowcol.new(bm_gb2,_unset,2,:pixel,
			  :style,:group_box,
			  :resize?,_true,
			  :default_col_alignment,:fill,
			  :col_spacing,0,
			  :col_resize_values,{0,100},
			  :default_row_alignment,:fill,
			  :bottom_spacing,0)
	
	# Output Module Path
	bm_rc2 << rowcol.new(bm_rc1,_unset,2,:pixel,
			  :style,:nested,
			  :resize?,_true,
			  :col_resize_values,{100,0})
	label_item.new(bm_rc2,_self.message(:set_module_path))

	_self.action(:set_module_path).place_control_on(bm_rc2,:dialog,:has_border?,_false)

	# Path input and module suffix
	bm_rc3 << rowcol.new(bm_rc1,1,_unset,:pixel,
			  :style,:nested,
			  :col_alignment,:fill,
			  :resize?,_true,
			  :col_resize_values,{100,0})
	.items[:build_module_dir] <<
		text_item.new(bm_rc3,_unset,
			      :value,"c:\temp", #system.getenv("temp"),
			      :col_alignment,:fill,
			      :model,_self)

	val << "\"+_self.message(:build_module_name_default).split_by(% ).first          #"
	.items[:build_module_name_for_dir] <<
		label_item.new(bm_rc3,val,
			       :resize?,_true,
			       :col_alignment,:right)

	# Description
	label_item.new(bm_rc1,_self.message(:build_module_name))
	.items[:build_module_name] <<
		text_item.new(bm_rc1,_unset,
			      :value,_self.message(:build_module_name_default),
			      :model,_self,
			      :resize?,_true,
			      :col_alignment,:fill,
			      :change_selector,{:change_dialog|()|,:build_module_name},
			      :activate_selector,{:change_dialog|()|,:build_module_name})
	
	label_item.new(bm_rc1,_self.message(:build_module_description))
	.items[:build_module_description] <<
		text_item.new(bm_rc1,_unset,
			      :model,_self,
			      :value,_self.message(:build_module_description_default),
			      :change_selector,{:change_dialog|()|,:build_module_description},
			      :activate_selector,{:change_dialog|()|,:build_module_description})

	# Requirements
	label_item.new(bm_rc1,_self.message(:build_module_requires),:row_alignment,:top)

	req_rc << rowcol.new(bm_rc1,1,_unset,:pixel,
			    :style,:nested,
			    :resize?,_true,
			    :row_alignment,:fill,
			    :col_resize_values,{50,50})

	simple_font << font.new_with_properties(:type,:logical,:name,"fixed",:point_size,12)
	.items[:build_module_requires] <<
		text_window.new(req_rc,4,20,_unset,
				:contents,_self.message(:build_module_requires_default),
				:font,simple_font,
				:resize?,_true,
				:min_width,100,
				:col_alignment,:fill,
				:row_alignment,:fill,
				:horizontal_scrollbar?,_true )

	adm << _self.all_defined_modules("")
	
	tm_gb << .items[:all_def_module_gb] <<
		group_box.new(req_rc,_self.message(:defined_modules,adm.size,adm.size),
			       :resize?,_true,
			       :col_alignment,:fill,:row_alignment,:fill)

	tm_gb_rc << rowcol.new(tm_gb,_unset,1,:pixel,:style,:nested,:resize?,_true)
	.items[:all_def_module_filter] <<
		text_item.new(tm_gb_rc,_self.message(:defined_module_filter_label),
			      :model,_self,
			      :width,10,
			      :resize?,_true,
			      :col_alignment,:fill,
			      :balloon_help_text,_self.message(:defined_module_filter_tt),
			      :incremental_change_selector,:|filter_defined_module_list()|)
	
	.items[:all_def_modules] <<
		simple_list_item.new(tm_gb_rc,
				     :items,adm,
				     :mode,:many,
				     :max_width,50,
				     :col_alignment,:fill,
				     :row_alignment,:fill,
				     :resize?,_true)
	.items[:all_def_modules].menu << _self.all_defined_modules_popup()
	
	# TEST MODULE Group Box.
	tm_rc << rowcol.new(top_rc,_unset,1,:pixel,
			    :style,:nested,
			    :resize?,_true,
			    :col_resize_values,{0,100},:row,2,:col,2)

	tm_gb << group_box.new(tm_rc,_self.message(:test),:resize?,_true)
	tm_rc1 << rowcol.new(tm_gb,_unset,1,:pixel,
			     :style,:button_box)
	
	.items[:dd_show_alerts?] << toggle_item.new(tm_rc1,_self.message(:alerts?))
	
	_self.action(:build_module).place_control_on(tm_rc1,:dialog)
	_self.action(:build_and_activate).place_control_on(tm_rc1,:dialog)
	_self.action(:reactivate_dialog).place_control_on(tm_rc1,:dialog)

	>> top_rc
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.all_defined_modules(filter)
	## 
	## Return a rope of all defined module names.
	
	rp << rope.new()

	_for m _over sw_module_manager.defined_modules.fast_elements()
	_loop
		_if m.name _isnt _unset 
		_then
			_if filter.empty? _orif
			    m.name.index_of_seq(filter) _isnt _unset 
			_then
				rp.add(m.name.write_string.trim_spaces())
			_endif
		_endif
	_endloop

	>> rp
_endmethod
$
_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.all_defined_modules_popup()
	## 
	## Return the popup for moving defined module names to and
	## from the 'Requires' list.
	
	pm << popup_menu.new(.items[:all_def_modules])

	button_item.new_safe(pm,_self.message(:add_to_requires),
			     _self,:|add_to_requires()|)

	button_item.new_safe(pm,_self.message(:remove_from_requires),
			     _self,:|remove_from_requires()|)
	>> pm
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.filter_defined_module_list()
	## 
	## Filter the defined modules list based on the filter text.
	
	filter << .items[:all_def_module_filter].value.default("")
	adm << _self.all_defined_modules(filter)
	siz << sw_module_manager.defined_modules.size
	
	.items[:all_def_modules].items << adm
	.items[:all_def_module_gb].label << _self.message(:defined_modules,adm.size,siz)
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.add_to_requires()
	## 
	## Add selected elements to the requires list, if they are not
	## already there.
	
	sel << .items[:all_def_modules].selected_items
	sp  << .items[:build_module_requires].contents.default("").split_by(%newline)
	txt << .items[:build_module_requires].contents.write_string

	_for s _over sel.fast_elements()
	_loop
		_if sp.index_equal_of(s) _is _unset 
		_then
			txt +<< write_string(s,%newline)
		_endif
	_endloop

	.items[:build_module_requires].contents << txt
_endmethod
$
_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.remove_from_requires()
	## 
	## Remove selected elements from the requires list, if present.
	## 

	target << :build_module_requires
	
	sp << .items[target].contents.default("").split_by(%newline)

	txt << ""

	sel << .items[:all_def_modules].selected_items

	_for s _over sp.fast_elements()
	_loop
		_if sel.index_equal_of(s) _is _unset 
		_then
			txt +<< write_string(s,%newline)
		_endif
	_endloop

	.items[target].contents << txt
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_module_path()
	## 
	## Select a system path.

	_if .items[:select_path] _is _unset 
	_then
		.items[:select_path] << file_dialog.new(_self,:|int!set_module_path()|,:class_name,
							:operation,:select_directory,
							:title,_self.message(:select_module_path))
	_else
		.items[:select_path].directory << .items[:build_module_dir].value
	_endif
	
	.items[:select_path].activate()
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.int!set_module_path(dir)
	## 
	## Store the module path based on user input.
	.items[:build_module_dir].value  << dir
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.build_module()
	## 
	## Build the module directory structure and write the dialog code to the class files.

	mod_name << .items[:build_module_name].value.split_by(% ).first.as_symbol()

	_dynamic !dd_show_alerts?! << .items[:dd_show_alerts?].value.default(_false)

	_if _not sw_module_manager.module_is_defined?(mod_name) _orif
	    _self.module_missing?(mod_name)
	_then 
		_self.build_module_structure()
	_endif

	_self.write_code_to_module()
	_self.copy_icons_to_module()
	_self.load_module()

	_self.action(:reactivate_dialog).enabled? << _true 
	_self.action(:explore_code).enabled? << _true
	_self.current_dialog().built? << _true
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.validate_package()
	## 
	## Check that the dialog package exists and create it if missing.
	_if (pname << .items[:dialog_package].value).default("").lowercase.empty?
	_then
		pname << "user"
	_endif

	pname << pname.as_symbol()

	_if package.all_packages[pname] _is _unset
	_then
		# Create the package so the dialog code can be loaded.
		package.new(pname)

		# Update the package chooser to in include the new package
		.items[:dialog_package].items << sorted_collection.new_from_iter(package.all_packages,:|fast_keys()|)
		.items[:dialog_package].value << pname.write_string
	_endif 
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.module_missing?(mod_name)
	## 
	## Return TRUE if the module.def for the module MOD_NMAME is missing.
	
	parent_dir << .items[:build_module_dir].value
	sp << .items[:build_module_name].value.split_by(% )

	>> _not system.file_exists?(parent_dir + "\" + sp.first + "\module.def")    #"
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.check_product_def(parent_dir)
	## 
	## Check for a product.def higher up the directory tree from
	## PARENT_DIR. 
	
	pd << parent_dir.write_string

	_loop
		_if system.file_exists?(pd+"\product.def")
		_then
			_return 
		_endif

		_if (i << pd.rindex_of_seq("\")) _is _unset #"
		_then
			_leave
			
		_endif 

		pd << pd.slice(1,i-1)
	_endloop

	# No product.def found ... make one.

	file << external_text_output_stream.new(parent_dir+"\product.def")
	file.write(_self.message(:default_product_def))
	file.close()
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.build_module_structure()
	## 
	## Build the module structure ready for population with
	## autogenerated code and copied resources.
	
	parent_dir << .items[:build_module_dir].value

	_self.check_product_def(parent_dir)

	sp << .items[:build_module_name].value.split_by(% )
	module_dir << parent_dir + "\" + sp.first     #"
	module_ver << sp.last
	
	args          << args.default( {} )
	
	description << .items[:build_module_description].value.default("")
	requires    << .items[:build_module_requires].contents.default("").write_string
	resource_data << property_list.new_with( :base, {:data, :bitmaps},
						 :en_gb, {:messages, :help})

	# Create module directory
	_self.make_or_reuse_directory( module_dir )
	
	# Create source directory
	source_dir << system.pathname_down( module_dir, :source )
	_self.make_or_reuse_directory( source_dir )

	# Create load_list.txt file in module root containing source/
	load_list_file << system.pathname_down( module_dir, "load_list.txt" )
	stream << external_text_output_stream.new( load_list_file )
	_protect
		stream.write( "source/", newline_char )
	_protection
		_if stream _isnt _unset
		_then
			stream.close()
		_endif
	_endprotect

	# Create an empty load_list.txt file in source directory
	load_list_file << system.pathname_down( source_dir, "load_list.txt" )
	stream << external_text_output_stream.new( load_list_file )
	_if stream _isnt _unset
	_then
		dc << _self.current_dialog().dialog_class
		stream.write(dc,%newline,dc+"_framework",%newline,dc+"_plugin")
		stream.close()
	_endif
	
	# Create the module.def file
	def_file << system.pathname_down( module_dir, "module.def" )
	stream << external_text_output_stream.new( def_file )
	_protect
		stream.write( sp.first, tab_char, module_ver, newline_char )
		_if description _isnt _unset
		_then
			stream.write( newline_char, "description", newline_char )
			stream.write( tab_char, description, newline_char )
			stream.write( "end", newline_char, newline_char )

			stream.write( "requires", newline_char )
			_for r _over requires.split_by(newline_char).fast_elements()
			_loop
				_if _not r.write_string.empty?
				_then
					tr << r.trim_spaces()
					stream.write( tab_char, tr, newline_char)					
				_endif
			_endloop
			
			stream.write( "end", newline_char, newline_char )
		_endif
	_protection
		_if stream _isnt _unset
		_then
			stream.close()
		_endif
	_endprotect

	# If any resources have been specified create the appropriate directories
	_if _not resource_data.empty?
	_then
		# Create resources directory
		resources_dir << system.pathname_down( module_dir, :resources )
		_self.make_or_reuse_directory( resources_dir )

		_for lang, resources _over resource_data.fast_keys_and_elements()
		_loop
			# Create language directories
			lang_dir << system.pathname_down( resources_dir, lang )
			_self.make_or_reuse_directory( lang_dir )

			_for resource _over resources.fast_elements()
			_loop
				dir << system.pathname_down( lang_dir, resource )
				_self.make_or_reuse_directory( dir )
			_endloop
		_endloop
	_endif

_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.write_code_to_module()
	## 
	## Write the generated code to the module.

	parent_dir << .items[:build_module_dir].value
	sp << .items[:build_module_name].value.split_by(% )

	source_dir << parent_dir  + "\" + sp.first + "\source"   #"
	_self.current_dialog().write_source_files(source_dir)

	# XML files
	xml_dir << parent_dir + "\" + sp.first + "\resources\base\data"   #"
	_self.current_dialog().write_xml_files(xml_dir)
	
	# MSG files
	msg_dir << parent_dir + "\" + sp.first + "\resources\en_gb\messages"   #"
	_self.current_dialog().write_msg_files(msg_dir)
	
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.copy_icons_to_module()
	## 
	## Copy icons from SELF's resources to the target module.
	
	parent_dir << .items[:build_module_dir].value
	sp << .items[:build_module_name].value.split_by(% )
	
	# Raster Image files
	dir << parent_dir + "/" + sp.first + "/resources/base/bitmaps/"
	_self.current_dialog().copy_icon_files(dir)
_endmethod
$
_pragma(classify_level=restricted)
_private _method dialog_designer.make_or_reuse_directory( dirname )
	##
	## Make or reuse directories as appropriate.

	_if _not system.file_exists?( dirname )
	_then
		system.mkdir( dirname )
	_endif

_endmethod
$

_pragma(classify_level=restricted)
_method dialog_designer.load_module()
	## 
	## Load the module generated for the current design.
	
	sp << .items[:build_module_name].value.split_by(% )

	_local mn << sp.first.as_symbol()

	parent_dir << .items[:build_module_dir].value
	module_dir << parent_dir + "\" + sp.first   #"

	_if _not sw_module_manager.module_is_defined?(mn) 
	_then
		write(%newline,_self.message(:begin_loading_module_definition,mn,module_dir))
		sw_module_manager.load_module_definition(module_dir)	
	_endif

	sw_module_manager.load_module(mn,_unset,:force_reload?,_true)
	write(_self.message(:end_loading))

	_return _true 
_endmethod
$

_pragma(classify_level=restricted)
_method dialog_designer.build_and_activate()
	## 
	## Build, load and open the module dialog.  The process
	## switches to the package defined for this dialog while
	## compiling and re-activating.

	_self.validate_package()
	
	_dynamic !current_package!

	_if (diag_package << package.all_packages[_self.current_dialog().dialog_package.as_symbol()]) _isnt _unset
	_then 
		!current_package! << diag_package
	_endif 

	_self.close_test_dialog()
	_self.build_module()
	_self.reactivate_dialog()

	!current_package! <<  package.all_packages[:user]
_endmethod
$

_pragma(classify_level=restricted)
_method dialog_designer.reactivate_dialog()
	## 
	## Re-activate the design WITHOUT re-loading the module, the
	## bitmap cache is cleared so modified images will be visible.

	_self.close_test_dialog()

	smallworld_product.clear_bitmap_cache()
	
	# Wait for the module load to complete before continuing...
	_self.load_module()

	.items[:test_module] << _self.current_dialog().test_dialog()

	tf << _self.top_frame
	pos << pixel_coordinate(tf.position.x + tf.width.floor + 8,tf.position.y)
	.items[:test_module].activate_dialog().top_frame.position << pos
_endmethod
$

_pragma(classify_level=restricted)
_method dialog_designer.explore_code()
	## 
	## Launch the Windows file explorer 
	
	parent_dir << .items[:build_module_dir].value
	sp << .items[:build_module_name].value.split_by(% )
	source_dir << parent_dir  + "\" + sp.first + "\source"    #"
	
	cmd << write_string("explorer.exe ",%",source_dir,%")

	system.do_command(cmd)
_endmethod
$



_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.update_titlebar()
	## 
	## Update the titlebar to show the current dialog class as well.
	_self.top_frame.title << _self.message(:dialog_designer,_self.current_dialog().dialog_class)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.post_activation()
	## 
	## Last jobs as the GUI activates.  Since a number of the tabs
	## will be hidden, the tab box is hidden from the user using a
	## window stack.  Once all the tabs that we want to hide are
	## gone, the tab_box is made visible as a whole.  This avoids
	## the multiple re-rendering flashes that occur whenever a tab
	## changes visibility.

	.items[:properties_gb1].height << 108
	
	_self.action(:new_dialog).execute_action()
	_self.action(:show_rowcol_cells).value << _true
	_self.action(:select_mode).value << _true

	# Hide some of the tabs ..
	_for i _over {2,3,4,5,7}.elements()
	_loop 
		.items[:tb].pages[i].unmanage()
	_endloop

	_self.action(:use_magik_xml).value << _true
	_self.action(:use_module_properties).value << _true

	# Make the "GUI Layout" tab the foremost.
	.items[:tb].active_page << .items[:tb].pages[1]

	# Set the databuses for the element editors.
	.items[:wa_editor].databus << _self.databus
	.items[:menubar_editor].databus << _self.databus
	.items[:statusbar_editor].databus << _self.databus
	.items[:docks_editor].databus << _self.databus

	# Make the tab box visible.
	.items[:ws].value << :tab_box

	# Update the application consumer/producer lists
	_self.update_app_pro_con_lists()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_insertion_mode(type,val)
	## 
	## If VAL = TRUE, switch to TYPE mode, else reset to
	## SELECT_MODE.

	_if .items[:changing_mode?].default(_false)
	_then
		_return 
	_endif

	.items[:changing_mode?] << _true
	
	_if val 
	_then
		_self.set_widget_toggles(type)
	_else
		_self.set_widget_toggles(:select_mode)
	_endif
	
	.items[:changing_mode?] << _false
	
	_self.set_cursor(type,val)
	_self.clear_selection_bb(_true)	
	_self.clear_insertion_area()
	_self.reset_focus()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.reset_focus()
	## 
	## Reset the focus to the canvas to avoid the annoying 'current'
	## gui widget indicator.
	
	.canvas.set_focus()
_endmethod
$
_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.int!set_insertion_mode(type)
	## 
	## Toggle/Untoggle the action TYPE.
	
	_self.action(type).value << _not _self.action(type).value.default(_false)
_endmethod
$

dialog_designer.define_shared_variable(:cursor_for_mode,property_list.new(),:public)
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_cursor(type,val)
	## 
	## if VAL=TRUE Set the cursor to be TYPE, else set it to
	## 'select_mode'.
	
	_if _not val 
	_then
		type << :select_mode
	_endif

	type << type.default(:select_mode)

	_if _self.cursor_for_mode[type] _is _unset 
	_then
		cur << smallworld_product.get_cursor(type,:dialog_designer)
		_self.cursor_for_mode[type] << cur
	_endif

	pbb  << .canvas.bounds
	hs << hotspot.new(_self.cursor_for_mode[type],{0,0,0,pbb.ymax,pbb.xmax,pbb.ymax,pbb.xmax,0,0,0})

	.canvas.hotspots << {hs}

	.items[:current_mode] << type

	_self.set_cursor_status(type)

_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_cursor_status(type)
	## 
	## Update the statusbar text (:dialog_info) to prompt the
	## user. 

	_if type _isnt :select_mode
	_then
		msg << _self.message(:insert_prompt,_self.message(type))
	_else
		msg << _self.message(type)
	_endif
	
	_self.framework.update_statusbar(:prompt,:text,msg)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_widget_toggles(type)
	## 
	## Manager the widget toggles, only one can be TRUE.

	_for a _over _self.widget_actions.elements()
	_loop
		_self.action(a).value << _self.action(a).name _is type
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.new_dialog()
	## 
	## Create a new dialog and make it current in the GUI.

	_self.action(:new_dialog).enabled? << _false
	
	next_class << _self.next_dialog_class()
	
	.dialog_list.add_last(dialog_design.new(next_class))
	.items[:current_dialog_i] << .dialog_list.size

	.items[:tb].active_page << .items[:tb].pages[1]
	
	_self.render_current_dialog()

	.items[:wa_editor].edit(_unset)
	.items[:wa_editor].set_choice_items(_self.element_list())

	_self.changed(:menubar_list,:refresh)
	_self.changed(:statusbar_list,:refresh)

	_self.action(:dialog_list).items << _self.dialog_list_items()
	_self.action(:dialog_list).value << .items[:current_dialog_i]

	_self.action(:delete_dialog).enabled? << .dialog_list.size > 1

	_self.action(:dialog_class_list).items << _self.dialog_class_list_items()

	_self.change_dialog(:build_module_name)
	_self.update_gui_for_dialog()

	_self.action(:new_dialog).enabled? << _true

_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.used_dialog_class?(test_name)
	## 
	## Return TRUE if TEST_NAME is already in the list of dialogs.
	
	_for d _over .dialog_list.default({}).fast_elements()
	_loop
		_if d.dialog_class = test_name
		_then
			_return _true 
		_endif
	_endloop

	>> _false 
_endmethod
$
_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.next_dialog_class()
	## 
	## Return the next dialog class that is not in the current list
	## of dialog classes.
	
	base_name << "default_class"
	test_name << "default_class"
	cnt << 0

	_loop
		_if _self.used_dialog_class?(test_name)
		_then
			dig << _if (cnt +<<1) < 10
			       _then
				       >> write_string("0",cnt)
			       _else
				       >> cnt.write_string
			       _endif
			
			test_name << base_name + "_" + dig

			_continue
		_else
			_leave 
		_endif
	_endloop

	>> test_name
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.use_menubar(val)
	## 
	## Hide/Unhide the menubar tab depending on VAL.

	_dynamic !switching_dialogs?!
	_if !switching_dialogs?!.default(_false)
	_then
		_return 
	_endif
	
	_self.current_dialog().use_menubar? << val
	
	_if val
	_then
		.items[:tb].pages[2].manage()
		.items[:tb].active_page << .items[:tb].pages[2]
		_self.tab_changed(2)
	_else 
		.items[:tb].pages[2].unmanage()
	_endif

	.items[:menubar_editor].edit("")
	.items[:menubar_editor].set_choice_items(_self.menubar_element_list())
	
	_self.changed(:menubar_list,:refresh)
	_self.refresh_view()

	_self.update_gui_for_dialog()

_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.menubar_spec_update(which,what,newval)
	## 
	## Update the menubar GUI when WHICH element's WHAT field gets
	## the value NEWVAL.

	_for m _over _self.current_dialog().menubar.fast_elements()
	_loop
		_for dt _over m.fast_trees()
		_loop
			_if dt.value[:name] = which.name
			_then
				dt.value[what] << newval
			_endif
		_endloop
	_endloop

	sel << .items[:menubar].tree_manager.selection

	.items[:menubar_editor].edit("")
	.items[:menubar_editor].set_choice_items(_self.menubar_element_list())

	.items[:menubar].tree_manager.selection << sel
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.use_statusbar(val)
	## 
	## Hide/Unhide the statusbar tab depending on VAL.

	_dynamic !switching_dialogs?!
	_if !switching_dialogs?!.default(_false)
	_then
		_return 
	_endif
	
	_if val
	_then
		.items[:tb].pages[3].manage()
		.items[:tb].active_page << .items[:tb].pages[3]
		_self.tab_changed(3)
	_else 
		.items[:tb].pages[3].unmanage()
	_endif
	
	 _self.current_dialog().use_statusbar? << val
	
	.items[:statusbar_editor].edit("")
	.items[:statusbar_editor].set_choice_items(_self.statusbar_element_list())
	
	_self.changed(:statusbar_list,:refresh)
	_self.refresh_view()
	_self.update_gui_for_dialog()

_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.use_docks(val)
	## 
	## Hide/Unhide the docks tab depending on VAL.

	_dynamic !switching_dialogs?!
	_if !switching_dialogs?!.default(_false)
	_then
		_return 
	_endif
	
	_if val
	_then
		.items[:tb].pages[4].manage()
		.items[:tb].active_page << .items[:tb].pages[4]
		_self.tab_changed(4)
	_else
		.items[:tb].pages[4].unmanage()
	_endif
	
	 _self.current_dialog().use_docks? << val

	.items[:docks_editor].edit("")
	.items[:docks_editor].set_choice_items(_self.docks_element_list())
	
	_self.changed(:docks_list,:refresh)
	_self.refresh_view()
	_self.update_gui_for_dialog()
_endmethod
$
_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.docks_update(which,what,newval)
	## 
	## Update the docks GUI when WHICH element's WHAT field gets
	## the value NEWVAL.

	sel << .items[:docks].tree_manager.selection

	obj << sel.an_element()

	_if obj.level _is 5
	_then
		obj.value[:name] << which.name
		obj.styled_string.int!styled_string[2] <<
			{which.image_file_name.default("dock_action"),which.image_module_name}
		obj.value[:image_file_name] << which.image_file_name.default(:dock_action)
		obj.value[:image_module_name] << which.image_module_name.default(:dialog_designer)
		obj.value[:image] << {which.image_file_name,which.image_module_name}
		obj.value[:action_message] << which.action_message
		obj.value[:control_type] << which.control_type
	_endif

	sel.empty()
	sel.add(obj)

	.items[:docks_editor].edit("")
	.items[:docks_editor].set_choice_items(_self.docks_element_list())
	.items[:docks].tree_manager.selection << sel

	_self.changed(:docks_list,:refresh)
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.refresh_view()
	## 
	## Refresh the rendered gui in the "GUI Layout" tab and the
	## editor in that tab.

	# Debug ...
	#!traceback!(!terminal!)

	_if _self.current_dialog() _isnt _unset 
	_then
		_self.render_current_dialog()	
	_endif

	# Reset Editors for current dialog (since with Tabs and
	# WindowStacks the only elements visible on the active page are
	# listed in the gui_layout_editor).
	.items[:wa_editor].set_choice_items(_self.element_list())

	_self.reset_focus()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.render_current_dialog()
	## 
	## Render the current dialog.  This rendering will populate all
	## the element footprint and drop area rectangles across the dialog.
	
	_self.clear_selection_bb(_true)
	.canvas.clear()
	
	_dynamic !dialog_element_footprints! << equality_hash_table.new()
	_dynamic !rowcol_cells! << equality_hash_table.new()
	_dynamic !show_rowcol_cells?! << _self.action(:show_rowcol_cells).value.default(_false)
	_dynamic !dialog_pseudo_buttons! << equality_hash_table.new()

	_self.current_dialog().render_on(.canvas)
	
	.footprints   << !dialog_element_footprints!
	.rowcol_cells << !rowcol_cells!
	.items[:pseudo_buttons] << !dialog_pseudo_buttons!

	_self.refresh_selection_bb()

	_self.update_insertion_availability()

	# Enable/dissable save button 
	_self.action(:save_to_file).enabled? << _self.current_dialog().save_filename _isnt _unset
	_self.action(:save_to_file).tooltip  << write_string(_self.message(:save),"  ",
							     _self.current_dialog().save_filename.default(""))
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.refresh_selection_bb()
	## 
	## Refresh the selection bounding box.
	
	.items[:xor_bb] << _unset
	_self.set_current_element(.items[:wa_editor].element)	
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.update_insertion_availability()
	## 
	## Control if the radio_item should be insertable ... can only
	## insert radio buttons inside a radio_group object.
	
	radio_item? << _false 
	_for el _over _self.current_dialog().gui_elements().fast_elements()
	_loop
		_if el.class_name _is :dd_radio_group
		_then
			radio_item? << _true
			_leave 
		_endif
	_endloop

	_self.action(:radio_item).enabled? << radio_item?
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.show_rowcol_cells()
	## 
	## Refresh the view, the rowcol cell will be shown depending on
	## the state of the "show_rowcol_cells" toggle.

	_self.refresh_view()
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.clear_insertion_area()
	## 
	## Clear the insertion area indicator.
	
	_if .items[:xor_bb] _isnt _unset 
	_then 
		.canvas.xor_line(_self.insertion_line_style,.items[:xor_bb].coords)
		.items[:xor_bb] << _unset
	_endif 
	
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.changed_mouse_position(x,y,c)
	## 
	## React to the mouse moving across the "GUI Layout" canvas.

	_if (footprint << _self.footprint_at(x,y)) _isnt _unset 
	_then
		wgt << .footprints[footprint]
		mode <<  .items[:current_mode].default(:select_mode)

		_if mode _is :select_mode
		_then
			_self.select_prompt(wgt)
		_elif (mode _isnt :radio_item _andif
		      _self.rowcol_like_objects.includes?(wgt.class_name)) _orif
		      (mode _is :radio_item _andif wgt.class_name _is :dd_radio_group)
		_then 
			_self.insert_prompt(wgt,x,y)
		_else
			_self.show_insertion_area(_unset , _false)
		_endif
	_elif .items[:current_mode].default(:select_mode) _is :select_mode
	_then
		_self.framework.update_statusbar(:prompt,:text,_self.message(:select_mode))
	_else
		_self.clear_insertion_area()
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.dragged_mouse_position(x,y,c)
	## 
	## React when the mouse is dragged to position X,Y.

	_if (footprint << _self.footprint_at(x,y)) _is _unset _orif
	    .items[:current_gui_layout_element] _is _unset 
	_then
		_self.framework.update_statusbar(:prompt,:text,"")
	_else
		wgt << .footprints[footprint]
		cel << .items[:current_gui_layout_element]
		mode << cel.class_name

		# No dragging of the frame or the topmost rowcol.
		_if mode _is :frame _orif cel.parent.class_name _is :frame
		_then
			_return
		_endif 
		
		_if (mode _isnt :radio_item _andif
		      _self.rowcol_like_objects.includes?(wgt.class_name)) _orif
		      (mode _is :radio_item _andif wgt.class_name _is :dd_radio_group)
		_then
			_self.insert_prompt(wgt,x,y)

			.items[:dragged?] << .items[:start_drag_xy] _isnt _unset _andif
					     (.items[:start_drag_xy] - pixel_coordinate(x,y)).abs > 20
		_else
			_self.show_insertion_area(_unset , _false)
			_self.framework.update_statusbar(:prompt,:text,"")
		_endif
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.insert_prompt(rc,x,y)
	## 
	## Update the statusbar prompt based on where the cursor is.

	_for bb,v _over .rowcol_cells.fast_keys_and_elements()
	_loop
		_if v[1] = rc _andif bb.at?(x,y)
		_then
			_if v[2].class_name _is :float _orif 
			    v[3].class_name _is :float  
			_then
				_self.show_insertion_area(bb,_true)		

			_elif rc.empty_cell?(v[2],v[3])  
			_then
				_if .items[:current_mode].default(:select_mode) _isnt :select_mode _orif
				    .items[:dragged?].default(_false) 
				_then
					insert_wgt << _self.message(.items[:current_mode])
					msg << _self.message(:insert_prompt,insert_wgt)
					_self.framework.update_statusbar(:prompt,:text,msg)

					_self.show_insertion_area(bb,_true)
				_endif				
			_endif

			# Exit early.
			_return 
		_endif
	_endloop

	_self.clear_insertion_area()

_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.show_insertion_area(bb, check?)
	## 
	## Show the insertion area BB.  If Check=FALSE and BB = the
	## current insertion area, then no action is taken.

	_if (check? _andif bb = .items[:xor_bb]) 
	_then
		_return 
	_endif

	_if .items[:xor_bb] _isnt _unset 
	_then
		.canvas.xor_line(_self.insertion_line_style,.items[:xor_bb].coords)
	_endif

	_if bb _isnt _unset 
	_then
		.canvas.xor_line(_self.insertion_line_style,bb.coords)	
	_endif
	.items[:xor_bb]  << bb
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.select_prompt(wgt)
	## 
	## Update the statusbar to show an appropriate prompt for the
	## the current insertion widget type.
	
	_self.framework.update_statusbar(:prompt,:text,
					 _self.message(:select_prompt,_self.message(wgt.class_name)))
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.button_pressed(x,y)
	## 
	## React when the user clicks on the "GUI Layout" canvas.
	
	_if .items[:current_mode].default(:select_mode) _is :select_mode
	_then
		_self.select_an_element(x,y)			
	_else
		_self.insert_an_element(x,y)
	_endif

	.items[:start_drag_xy] << pixel_coordinate(x,y)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.button_released(x,y,c)
	## 
	## React when the user releases the mouse button within the
	## "GUI Layout" canvas.

	_if .items[:current_mode].default(:select_mode) _is :select_mode _andif
	    .items[:dragged?].default(_false) _andif
	    .items[:current_gui_layout_element].parent.class_name _isnt :frame 
	_then
		_self.drag_an_element(x,y)
	_endif

	_self.clear_insertion_area()
	
	.items[:dragged?] << _false 
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.drag_an_element(x,y)
	## 
	## Drag an element to a drop point at XY.

	_if _self.self_drag_at?(x,y)
	_then
		_return 
	_endif

	start_fp << .items[:current_fp]
	start_el << .footprints[start_fp].deep_copy()
	
	end_fp << _self.footprint_at(x,y)
	end_el << .footprints[end_fp] 
	
	# Loop over the target rowcol to find the drop cell, if between
	# existing cells then insert a row & col first.
	good_drag? << _false 
	_for bb,v _over .rowcol_cells.fast_keys_and_elements()
	_loop
		_if v[1] = end_el _andif bb.at?(x,y) 
		_then
			# Handle insertion between existing RowCol cells.
			_if (v[2] + v[3]).class_name _is :float
			_then
				end_el.expand_at(v[2],v[3])
				v[2] << v[2].ceiling
				v[3] << v[3].ceiling
			_endif

			end_row << v[2]
			end_col << v[3]

			start_el.row << v[2]
			start_el.col << v[3]
			start_el.parent << end_el

			end_el.items.add(start_el)

			_self.handle_paned_window_parent(end_el,start_el,v[2],v[3])

			good_drag? << _true 
			_leave 
		_endif
	_endloop

	_if good_drag?
	_then 
		_self.delete_footprint(.footprints[start_fp])
		_self.update_gui_for_dialog()
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.self_drag_at?(x,y)
	## 
	## Check if this dragging event is a self drag.
	
	_if (start_fp << .items[:current_fp]) _is _unset _orif
	    (start_el << .footprints[start_fp].deep_copy()) _is _unset _orif
	    .items[:xor_bb] _is _unset 
	_then
		_return _true
	_endif

	end_fp << _self.footprint_at(x,y)
	_if (end_el << .footprints[end_fp]) _is _unset
	_then
		_return _true
	_endif
	
	>> _self.dragging_into_self?(end_el.dialog_element_id, start_el)
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.dragging_into_self?(end_id,start_rc)
	## 
	## Return TRUE if element ID already exists inclusively in rowcol RC.

	_if (start_id << start_rc.dialog_element_id) = end_id
	_then
		_return _true
	_endif
	
	_for e _over start_rc.dd_child_elements()
	_loop
		_if e.dialog_element_id = end_id
		_then
			_return _true 
		_endif
	_endloop

	>> _false 
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.select_an_element(x,y)
	## 
	## Select a design gui element at XY.

	_self.clear_selection_bb(_true)

	_if _self.do_pseudo_button_at(x,y) _then _return _endif 
	
	_if (fp << _self.footprint_at(x,y)) _isnt _unset
	_then
		ls << _self.selection_line_style

		s << fp.boundary.sectors
		s.xor_on(.canvas,ls)

		.items[:selection_sr] << s

		el << .footprints[fp]

		# Update Work Area Editor to show current selection.
		.items[:wa_editor].edit(el)
	_else
		#.items[:wa_editor].edit("")
	_endif

	_self.set_gui_layout_popup(fp)
	el << .items[:current_gui_layout_element] << .footprints[fp]
	_self.update_dd_clipboard_actions(el)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.update_dd_clipboard_actions(el)
	## 
	## Update the availability of clipboard actions (:delete,:copy)
	## based on the element EL.

	frame? << el _is _unset _orif
		el.class_name _is :frame
	bad? << el _is _unset _orif
		el.class_name _is :frame _orif
		_self.frame_like_classes.includes?(el.parent.class_name) 

	_self.action(:delete_element).enabled? << _not bad? 
	_self.action(:copy_element).enabled? << _not frame? 
	_self.action(:cut_element).enabled? << _not bad? 
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.do_pseudo_button_at(x,y)
	## 
	## React to the user clicking on rendered "button" in the "GUI
	## Layout" canvas.  If there is a button at XY then some action occurs.
	
	_for fp,val _over .items[:pseudo_buttons].fast_keys_and_elements()
	_loop
		_if fp.at?(x,y)
		_then
			args << val.slice_to_end(2)
			val[1].perform(_scatter args)

			_self.update_gui_for_dialog()
			
			_self.refresh_view()
			_self.databus_make_data_available(:elements,1)

			_return _true 
		_endif
	_endloop

	_return _false 
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_gui_layout_popup(fp)
	## 
	## Set the popup menu for the GUI Layout canvas depending on
	## which elementt is currently selected.
	
	el << .footprints[fp]
	pm << popup_menu.new(.canvas)
	
	_if el _is _unset _orif el.class_name _is :frame
	
	_then
		.canvas.menu << _unset
	_else
		_if el.class_name _is :dd_tab_box
		_then
			button_item.new_safe(pm,_self.message(:add_tab),_self,{:|add_tab()|,el})
			_if el.items.size > 1
			_then
				button_item.new_safe(pm,_self.message(:delete_tab),_self,{:|delete_tab()|,el})	
			_endif

			_self.move_actions(pm,el)
			separator_item.new(pm)
		_elif el.class_name _is :dd_window_stack
		_then
			button_item.new_safe(pm,_self.message(:add_stack_window),_self,{:|add_tab()|,el})
			button_item.new_safe(pm,_self.message(:delete_stack_window),_self,{:|delete_tab()|,el})
			separator_item.new(pm)
		_endif
		
		_if _not _self.frame_like_classes.includes?(el.parent.class_name)
		_then
			button_item.new_safe(pm,_self.message(:delete_element),_self,{:|delete_footprint()|,el})
			button_item.new_safe(pm,_self.message(:cut_element),_self,{:|cut_element()|,el})		
		_endif

		_if _self.action(:copy_element).enabled?.default(_false)
		_then
			button_item.new_safe(pm,_self.message(:copy_element),_self,{:|copy_element()|,el})
		_endif

		_if _self.rowcol_like_objects.includes?(el.class_name) _andif
		    _not el.items.empty?
		_then
			button_item.new_safe(pm,_self.message(:empty),_self,{:|empty_rowcol()|,el})		
		_endif

		.canvas.menu << pm
	_endif

	.items[:current_fp] << fp
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.move_actions(pm,el)
	## 
	## Populate the gui_layoutp opup_menu with the actions to move
	## a tab to another position in the tab order.
	
	n << el.properties[:active_page_n]
	s << el.items.size
	
	_if s > 1
	_then
		pd << pulldown_menu.new()
		menu_button_item.new(pm,_self.message(:move_tab,n,s),pd)
		
		_for i _over 1.upto(s)
		_loop
			_if i <> n
			_then
				button_item.new_safe(pd,i.write_string,_self,{:|move_tab()|,el,i})
			_endif
		_endloop
	_endif
	
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.tab_refresh(tb)
	## 
	## Refresh the view, tailored for when modifying tabs?
	
	_self.set_element_dialog_id(tb.active_page)
	_self.update_gui_for_dialog()
	_self.refresh_view()
	_self.databus_make_data_available(:current_gui_layout_element,_unset)
	_self.databus_make_data_available(:elements,1)			
	_self.current_dialog().update_ws_driver(tb,tb.text_choice_item_driver,"")
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.add_tab(tb)
	## 
	## Add a tab to the design tab_box TB, then refresh/update the GUI.
	
	tb.add_tab()
	_self.tab_refresh(tb)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.delete_tab(tb)
	## 
	## Delete a tab from the design tab_box TB, then refresh/update the GUI.

	tb.delete_tab()
	_self.tab_refresh(tb)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.move_tab(tb,to)
	## 
	## Move the current tab of tab_box TB to position TO in the tab order.
	
	tb.move_tab(to)
	_self.tab_refresh(tb)
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.delete_element()
	## 
	## Delete the currently selected design element.

	_if .items[:tb].current_page _is 1 _andif
	    (el << .items[:current_gui_layout_element]) _isnt _unset _andif
	    el.class_name _isnt :frame _andif
	    el.parent.class_name _isnt :frame 
	_then
		_self.delete_footprint(el)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.delete_footprint(el)
	## 
	## Delete the footprint FP (and consequently the element
	## referenced by FP), then refreshed the view.

	el.parent.remove_element(el)

	_self.update_gui_for_dialog()

	_self.refresh_view()
	_self.databus_make_data_available(:current_gui_layout_element,_unset)
	_self.databus_make_data_available(:elements,1)		

	# Clear the popup menu
	_self.set_gui_layout_popup(_unset)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.cut_element()
	## 
	## Make a copy of the current element and the delete it.
	
	_self.copy_element()
	_self.delete_element()
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.copy_element()
	## 
	## Copy the currently selected element along with all elements
	## it may contain.
	
	_if .items[:tb].current_page _is 1 _andif
	    (el << .items[:current_gui_layout_element]) _isnt _unset 
	_then
		.items[:element_for_pasting] << el.deep_copy()

		_self.action(:paste_element).enabled? << _true
		_self.action(:paste_element).tooltip << _self.paste_element_tooltip()

		_self.action(:paste_element).execute_action()

		_self.action(:copy_element).enabled? << _false
		_self.action(:cut_element).enabled? << _false
	_endif
	
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.paste_element_tooltip()
	## 
	## Return a tooltip string appropriate for the current element
	## on the clipboard.
	
	cn << .items[:element_for_pasting].class_name

	cnt << 0
	_for i _over .items[:element_for_pasting].dd_child_elements()
	_loop
		cnt +<< 1
	_endloop

	>> _if cnt > 0
	   _then
		   >> _self.message(:paste_element_tt_n,cn,cnt)
	   _else
		   >> _self.message(:paste_element_tt_0,cn)
	   _endif
_endmethod
$



_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.empty_rowcol(rc)
	## 
	## Removes all elements from the RowCol RC, then refreshed the view.
	
	rc.empty_rowcol()
	
	_self.refresh_view()
	_self.databus_make_data_available(:current_gui_layout_element,rc)
	_self.databus_make_data_available(:elements,1)		
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.clear_selection_bb(_optional clear_cache?)
	## 
	## Clear the selection highlighting box.
	
	_if .items[:selection_sr] _isnt _unset 
	_then
		.items[:selection_sr].xor_on(.canvas,_self.selection_line_style)

		_if clear_cache?.default(_false)
		_then
			.items[:selection_sr] << unset
		_endif
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.element_at(x,y)
	## 
	## Return the element at XY.
	
	fp << _self.footprint_at(x,y)
	>> .footprints[fp]
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_current_element(which)
	## 
	## Set the current element to WHICH.
	
	_self.clear_selection_bb(_true)

	_if .footprints _is _unset 
	_then
		_return 
	_endif
	
	_for fp,e _over .footprints.fast_keys_and_elements()
	_loop
		_if e = which
		_then
			ls << _self.selection_line_style
			
			s << fp.boundary.sectors

			s.xor_on(.canvas,ls)

			.items[:selection_sr] << s
		_endif
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_current_menubar_element(a_menubar_element)
	## 
	## Set the current menubar element to A_MENUBAR_ELEMENT.

	sel << .items[:menubar].selection
	el << sel.an_element()

	_if a_menubar_element = ""
	_then
		.items[:menubar].selection.empty()
		_return 
	_endif
	 
	_if (el << sel.an_element()) _is _unset _orif
	     el.value[:name] <> a_menubar_element.name
	_then
		.items[:menubar].selection.empty()

		_for dt _over .items[:menubar].tree_manager.fast_trees()
		_loop
			_if dt.value[:name] = a_menubar_element.name
			_then
				.items[:menubar].selection.add(dt)
				_return 
			_endif
		_endloop
	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_current_statusbar_element(a_statusbar_element)
	## 
	## Set the current statusbar element to A_STATUSBAR_ELEMENT.

	sel << .items[:statusbar].selection
	el << sel.an_element()

	_if a_statusbar_element = ""
	_then
		.items[:statusbar].selection.empty()
		_return 
	_endif
	 
	_if (el << sel.an_element()) _is _unset _orif
	     el.value[:name] <> a_statusbar_element.id
	_then
		.items[:statusbar].selection.empty()

		_for dt _over .items[:statusbar].tree_manager.data.fast_elements()
		_loop
			_if dt.value[:id] = a_statusbar_element.id
			_then
				.items[:statusbar].selection.add(dt)
				_return 
			_endif
		_endloop
	_endif

	_self.refresh_statusbar()

_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.footprint_at(x,y)
	## 
	## Return the smallest footprint that overlaps X,Y.
	
	footprint << _unset

	_for fp,el  _over .footprints.default(property_list.new()).fast_keys_and_elements()
	_loop
		_if fp.at?(x,y) _andif
		    (footprint _is _unset _orif
		     fp.area < footprint.area)
		_then
			footprint << fp
		_endif
	_endloop

	>> footprint
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.insert_an_element(x,y)
	## 
	## Insert an element at XY of type corresponding to the active
	## inserion widget toggle.
	
	_if _self.do_pseudo_button_at(x,y) _then _return _endif 
	
	el << _self.element_at(x,y)

	_for bb,v _over .rowcol_cells.fast_keys_and_elements()
	_loop
		_if v[1] = el _andif
		    bb.at?(x,y) _andif el.empty_cell?(v[2],v[3])
		_then
			ex << _self.widget_exemplars[.items[:current_mode]]

			# Handle insertion between existing RowCol cells.
			_if (v[2] + v[3]).class_name _is :float
			_then
				el.expand_at(v[2],v[3])
				v[2] << v[2].ceiling
				v[3] << v[3].ceiling
			_endif

			_if ex.class_name _is :radio_item _andif
			    el.class_name _isnt :dd_radio_group
			_then
				_continue 
			_endif

			_if .items[:current_mode] _is :paste_element
			_then
				_self.paste_elements(el,v[2],v[3],.items[:element_for_pasting])
			_else 	
				wgt << ex.new_dialog_default(el,v[2],v[3],.items[:current_mode])

				_self.handle_paned_window_parent(el,wgt,v[2],v[3])
				
				_self.set_element_dialog_id(wgt)
				
				wgt.id_changed()
			_endif

			_self.render_current_dialog()

			.items[:wa_editor].set_choice_items(_self.element_list())
		_endif
	_endloop

	_self.update_gui_for_dialog()
	_self.update_dd_clipboard_actions(_unset)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.paste_elements(parent,row,col,el)
	## 
	## Paste the element EL and all its child elements into the
	## [ROW,COL] cell of PARENT.

	# Make copy, in case of multiple pastes...
	cel << el.deep_copy()

	cel.parent << parent
	cel.row << row
	cel.col << col
	parent.items.add(cel)

	_self.set_element_dialog_id(cel)

	# Update all the child elements so there are no repeated dialog_element_ids
	_for child_e _over cel.dd_child_elements()
	_loop
		_self.set_element_dialog_id(child_e)
	_endloop
_endmethod
$


_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.handle_paned_window_parent(el,wgt,r,c)
	## 
	## Special handling when inserting into a paned_window.
	
	_if el.class_name _isnt :dd_paned_window _then _return _endif 

	rc << max(r,c)
	s << el.items.size

	_if rc < s
	_then
		el.items.remove_last()
		el.items.add_nth(wgt,rc)
	_endif
_endmethod 
$


_pragma(classify_level=restricted, topic={dialog_designer})
_iter _method dialog_designer.fast_elements()
	## 
	## Iterator for the all the elements in the current_dialog.

	_for fp,el _over .footprints.default({}).fast_keys_and_elements()
	_loop
		_loopbody(el)
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.element_list()
	## 
	## List of elements in the current dialog.
	
	>> rope.new_from_iter(_self,:|fast_elements()|)
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.menubar_element_list()
	## 
	## Return a list of menubar elements suited to the dd_element_editor.
	
	_if (d << _self.current_dialog()) _isnt _unset 
	_then
		_return d.menubar_element_list()
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.docks_element_list()
	## 
	## Return a list of dock elements suited to the dd_element_editor.

	_if (d << _self.current_dialog()) _isnt _unset 
	_then
		_return d.docks_element_list()
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.element_ids()
	## 
	## Return a list of current element IDs for the current objects.
	
	rp << rope.new_with(:rowcol_01)

	_for el _over _self.current_dialog().gui_layout[:top_rc].gui_elements()
	_loop
		rp.add(el.dialog_element_id.default("").as_symbol())
	_endloop

	>> rp
_endmethod
$

_pragma(classify_level=restricted, topic={dialog_designer})
_method dialog_designer.set_element_dialog_id(wgt)
	## 
	## Set the element id of WGT to a unique value relative to all
	## others in the dialog design.
	
	_if {:dd_tab_box,:dd_window_stack}.includes?(wgt.class_name)
	_then
		_self.set_element_dialog_id(wgt.active_page)
	_endif

	cn << wgt.class_name.write_string

	_if cn.index_of_seq("dd_") _is 1
	_then
		cn << cn.slice_to_end(4)
	_endif
	cnt << 1

	e_ids << _self.element_ids()
 
	_loop
		id << write_string(cnt,%_,cn).as_symbol()

		id << 
			_if cnt < 10
			_then
				>> write_string(cn,:_0,cnt).as_symbol()
			_else
				>> write_string(cn,%_,cnt).as_symbol()
			_endif

		_if e_ids.index_of(id) _is _unset 
		_then
			wgt.set_property(:dialog_element_id,id)
			wgt.set_logical_properties()
			_return 
		_endif

		_if (cnt +<< 1) > 100
		_then
			write("too many elements of type ... ",cnt)
			_leave 
		_endif
	_endloop
_endmethod
$

#####################################################
#
# Databus
#
#####################################################

_pragma(classify_level=restricted, topic={dialog_designer})
dialog_designer.define_shared_constant(:databus_producer_data_types,
					  {:elements,
					   :all_element_ids,
					   :menubar_elements,
					   :statusbar_elements},
					  :public)
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.sw_databus_data_requested(data_type)
	## 
	## Respond to data requests.

	_if data_type _is :elements
	_then
		_return _self.element_list()
	_elif data_type _is :all_element_ids
	_then
		_return _self.element_ids()
	_elif data_type _is :menubar_elements
	_then
		_return _self.menubar_element_list()
	_elif data_type _is :statusbar_elements
	_then
		_return _self.statusbar_element_list()
	_endif
_endmethod
$
dialog_designer.define_shared_constant(:databus_consumer_data_types,
					  {:current_gui_layout_element,
					   :current_menubar_element,
					   :current_statusbar_element,
					   :refresh,
					   :refresh_selection_bb,
					   :refresh_magik_xml,
					   :ws_driver,
					   :menubar_spec_update},
					  :public)
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.sw_databus_data_available(data_type,data)
	## 
	## Respond to available data.

	_if data_type _is :current_gui_layout_element
	_then
		_self.set_current_element(data)
	_elif data_type _is :current_menubar_element
	_then
		_self.set_current_menubar_element(data)
	_elif data_type _is :current_statusbar_element
	_then
		_self.set_current_statusbar_element(data)
	_elif data_type _is :ws_driver
	_then
		_self.current_dialog().update_ws_driver(_scatter data)
	_elif data_type _is :refresh
	_then
		_if data _is :gui_layout
		_then
			# Make sure the Magik/XML is upto date.
			_self.dialog_class_list_value_changed(_self.action(:dialog_class_list).value)

			# Refresh the render to pick up changes.
			_self.render_current_dialog()
		_elif data _is :menubar
		_then 
			_self.changed(:menubar_list,:refresh)
		_elif data _is :docks
		_then
			#_self.changed(:docks_list,:refresh)
			ce << .items[:docks_editor].element
			_self.docks_update(ce,:name,ce.name)

			#!traceback!(!terminal!)
		_elif data _is :statusbar
		_then
			_self.changed(:statusbar_list,:refresh)
			_self.refresh_statusbar()
		_elif data _is :wa_editor_choice_list
		_then
			.items[:wa_editor].set_choice_items(_self.element_list())
		_endif
	_elif data_type _is :refresh_selection_bb
	_then
		_self.refresh_selection_bb()
	_elif data_type _is :refresh_magik_xml
	_then
		_self.refresh_magik_xml(6,_true)
	_elif data_type _is :menubar_spec_update
	_then
		_self.menubar_spec_update(_scatter data)
	_endif
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.file_selector(which)
	## 
	## Create a file selector of type WHICH (:save, :save_as or :open)
	
	_if .items[:file_selector] _is _unset 
	_then
		dir << sw_module_manager.module(:dialog_designer).safe_full_directory
		
		.items[:file_selector] <<
			file_dialog.new(_self,:|int!load_from_file()|,:class_name,
					:filter,"*.xml",
					:directory, dir)
	_else
		.items[:file_selector].directory << .items[:file_selector_dir]
	_endif

	fs << .items[:file_selector]

	_if which _is :open
	_then
		fs.operation << :open
		fs.title << _self.message(:load_dialog_xml)
		fs.ok_message << :|int!load_from_file()|
	_elif which _is :save
	_then 
		fs.operation << :save
		fs.title << _self.message(:save_dialog_xml)
		fs.ok_message << {:|int!save_to_file()|,_false}
	_else
		# Save As ...
		fs.operation << :save
		fs.title << _self.message(:save_dialog_xml)
		fs.ok_message << {:|int!save_to_file()|,_true}
	_endif

	>> .items[:file_selector]
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.load_from_file()
	## 
	## Activate the file selector and update the GUI after the file
	## selector has finished.
	
	_self.file_selector(:open).activate()
	
	_self.update_gui_for_dialog()
	_self.update_titlebar()
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.int!load_from_file(filename)
	## 
	## Load a dialog design from the XML file FILENAME.

	# Save the diretory we are loading from.
	.items[:file_selector_dir] << filename

	sx << simple_xml.read_element_file(filename)
	sx_class << sx.attributes["class"]

	# Handle a duplicate dialog class
	_if _self.used_dialog_class?(sx_class)
	_then
		_if _not _self.show_query(
				 {_self.message(:yes), _self.message(:no)},
				 {_true,_false},_false,
				 _self.message(:overwrite_existing_class?,sx_class))
		_then
			_return
		_endif

		_self.select_dialog_named(sx_class)
		_self.empty_rowcol(_self.current_dialog().gui_layout[:top_rc])
		_self.current_dialog().delete_menubar()
		_self.current_dialog().delete_statusbar()

		_self.set_insertion_mode(:select_mode,_true)
		_self.refresh_view()
		_self.update_gui_for_dialog()
		_self.update_titlebar()
	_else
		_self.new_dialog()
	_endif

	_self.current_dialog().parse_xml_into_design(sx)
	_self.current_dialog().save_filename << filename

	_self.dialog_list_value_changed(.items[:current_dialog_i])

	_self.render_current_dialog()
	.items[:wa_editor].set_choice_items(_self.element_list())

	_self.action(:dialog_list).items << _self.dialog_list_items()
	_self.update_gui_for_dialog()
_endmethod
$


_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.select_dialog_named(name)
	## 
	## Make the dialog NAME current.
	
	_for e _over _self.action(:dialog_list).items.fast_elements()
	_loop
		_if e[2] = name
		_then
			_self.action(:dialog_list).value << e[1]
			_return 
		_endif
	_endloop
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.save_to_file()
	## 
	## Save an XML description for the current dialog.  This save
	## overwrites the existing file at that location.
	
	_self.int!save_to_file(_false,_self.current_dialog().save_filename)
	_self.action(:save_to_file).enabled? << _false 
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.save_as()
	## 
	## Save the current dialog to a new name, overwriting a
	## pre-existing is verified.
	
	_self.file_selector(:save_as).activate()
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.int!save_to_file(check_for_existing?,filename)
	## 
	## Save the current dialog's XML description to FILENAME.  If
	## CHECK_FOR_EXISTING? is TRUE then overwriting an existing
	## file has to be confirmed by the user.

	_if check_for_existing? _andif
	    system.file_exists?(filename) _andif
	    _not _self.show_query(
			 {_self.message(:yes), _self.message(:no)},
			 {_true,_false},_false,
			 _self.message(:overwrite_existing_file?))
	_then
		_return 
	_endif
	
	_protect
		f << external_text_output_stream.new(filename)
		f.write(_self.current_dialog().xml_description())

		_self.current_dialog().save_filename << filename
		_self.action(:save_to_file).enabled? << _true 
	_protection
		f.close()
	_endprotect 
	
_endmethod
$


_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.delete_dialog()
	## 
	## Delete the current dialog.
	
	_self.current_dialog().build_module_requires << .items[:build_module_requires].contents.default("")

	_if _not _self.show_query(
			 {_self.message(:yes), _self.message(:no)},
			 {_true,_false},_false,
			 _self.message(:delete_current_dialog?,_self.current_dialog().dialog_class))
	_then
		_return
	_endif 

	i << .items[:current_dialog_i]
	.dialog_list.remove_nth(i)
	_self.action(:dialog_list).value << 1	
	_self.action(:dialog_list).items << _self.dialog_list_items()
	
	.items[:tb].active_page << .items[:tb].pages[1]
	_self.tab_changed(1)
	_self.refresh_view()

	_self.action(:delete_dialog).enabled? << .dialog_list.size > 1

_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.exit()
	## 
	## Close the framework, exiting the dialog designer.

	_self.close_test_dialog()
	_self.framework.close()
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.close_test_dialog()
	## 
	## Close the test dialog, if activated.
	
	_if .items[:test_module] _isnt _unset _andif
	    (d << .items[:test_module].dialogs.an_element()) _isnt _unset 
	_then
		d.close()
	_endif	
_endmethod
$



_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.use_magik_xml(val)
	## 
	## Hide/Unhide the Magik/XML tab.

	_if val
	_then
		.items[:magik_xml].manage()
		.items[:tb].active_page << .items[:tb].pages[6]
	_else
		.items[:tb].active_page << .items[:tb].pages[1]
		_self.tab_changed(1)
		.items[:magik_xml].unmanage()	
	_endif
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.use_module_properties(val)
	## 
	## Hide/Unhide the "Module" tab.

	_if val
	_then
		.items[:build_module].manage()
		.items[:tb].active_page << .items[:tb].pages[7]
	_else
		.items[:tb].active_page << .items[:tb].pages[1]
		_self.tab_changed(1)
		.items[:build_module].unmanage()	
	_endif
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.dialog_list_items()
	## 
	## Return the items list for the dialog choice item in the main toolbar.
	
	items << rope.new()

	_for i _over 1.upto(.dialog_list.default({}).size)
	_loop
		d << .dialog_list[i]
		items.add_last({i,d.dialog_class})
	_endloop

	>> items
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.dialog_list_value_changed(val)
	## 
	## Update the GUI when the selected dialog is changed.

	.items[:current_dialog_i] << val

	# Change the action toggles but don't update the GUI
	_dynamic !switching_dialogs?! << _true

	d << _self.current_dialog()

	_self.action(:use_menubar).value   << d.use_menubar?
	_self.action(:use_statusbar).value << d.use_statusbar?
	_self.action(:use_docks).value     << d.use_docks?
	_self.action(:use_databus).value   << d.use_databus?

	!switching_dialogs?! << _false
	
	.items[:tb].active_page << .items[:tb].pages[1]
	_self.tab_changed(1)
	
	_self.update_gui_for_dialog()
	_self.update_titlebar()
	_self.refresh_view()
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.reset_editors()
	## 
	## Reset editors to 'no selection' state.
	
	.items[:wa_editor].edit("")
	.items[:wa_editor].set_choice_items(_self.element_list())
	
	.items[:menubar_editor].edit("")
	.items[:menubar_editor].set_choice_items(_self.menubar_element_list())
	
	.items[:statusbar_editor].edit("")
	.items[:statusbar_editor].set_choice_items(_self.statusbar_element_list())	
_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.update_gui_for_dialog()
	## 
	## Update the GUI to match the current dialog.
	##
	## Reset the editors.
	## Refresh menubar,statusbar and docks lists.
	## Refresh databus and statusbar GUIs.
	## Hide/Unhide tabs as needed.
	## Populate module properties with current values.

	# Reset Editors for current dialog.
	_self.reset_editors()

	# Reset Menubar and Statusbar lists for current dialog.
	_self.changed(:menubar_list,:refresh)
	_self.changed(:statusbar_list,:refresh)
	_self.changed(:docks_list,:refresh)
	_self.refresh_statusbar()
	_self.refresh_databus()

	d << _self.current_dialog()

	# Update tab visibility to match the toggles
	_if d.use_menubar?
	_then	
		.items[:tb].pages[2].manage()		
	_else 
		.items[:tb].pages[2].unmanage()		
	_endif

	_if d.use_statusbar?
	_then
		.items[:tb].pages[3].manage()		
	_else 
		.items[:tb].pages[3].unmanage()		
	_endif
	
	_if d.use_docks?
	_then
		.items[:tb].pages[4].manage()		
	_else 
		.items[:tb].pages[4].unmanage()		
	_endif

	_if d.use_databus?
	_then
		.items[:tb].pages[5].manage()		
	_else 
		.items[:tb].pages[5].unmanage()		
	_endif

	

	# Update module properties in the GUI
	.items[:dialog_class].value << d.dialog_class.write_string
	.items[:dialog_extra_slots].value << d.dialog_extra_slots.write_string
	.items[:pragma_classify_level].value << d.pragma_classify_level
	.items[:pragma_usage].value << d.pragma_usage
	.items[:pragma_topic].value << d.pragma_topic
	.items[:build_module_name].value << d.build_module_name.write_string
	.items[:build_module_description].value << d.build_module_description.write_string
	.items[:build_module_requires].contents << d.build_module_requires.default("").write_string

	_self.action(:dialog_class_list).items << _self.dialog_class_list_items()
	_self.dialog_class_list_value_changed(_self.action(:dialog_class_list).value)

	# Force the GUI to update with respec to the module name
	_self.change_dialog(:build_module_name)

	save? << _self.current_dialog().save_filename _isnt _unset
	_self.action(:save_to_file).enabled? << save?

	# Control the reactivate and goto_explorer
	activate? << _self.current_dialog().built? _is _true
	_self.action(:explore_code).enabled? << activate?
	_self.action(:reactivate_dialog).enabled? << activate?
		
	_self.action(:delete_dialog).enabled? << _self.action(:dialog_list).items.size > 1
_endmethod
$


_pragma(classify_level=restricted, usage={redefinable})
_method dialog_designer.open()
	## 
	## Open a new instance of SELF.  No caching is done so each
	## time a new instance is created and activated.
	
	d << dialog_designer_plugin.new()
	>> d.activate_dialog()
_endmethod
$
